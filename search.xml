<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lab5</title>
      <link href="/2023/06/18/Lab5/"/>
      <url>/2023/06/18/Lab5/</url>
      
        <content type="html"><![CDATA[<p><strong>关键词：文件系统，IDE磁盘，磁盘驱动</strong></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ol><li><strong>外部存储设备驱动</strong>：实现 IDE 磁盘的用户态驱动程序，该驱动程序将通过系统调用的方式陷入内核，对磁盘镜像进行读写。</li><li><strong>文件系统结构</strong>：实现模拟磁盘的驱动程序以及磁盘上和操作系统中的文件系统结构，并实现文件系统操作的相关函数。</li><li><strong>文件系统的用户接口</strong>：为用户提供接口和机制使得用户程序能够使用文件系统，这主要通过一个用户态的文件系统服务来实现。</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>尽管进程运行时可以在它的地址存储空间存储一定量的信息，但存在：(1) 存储容量受虚拟地址空间大小限制，(2) 进程终止后信息丢失，(3) 不能让多个进程并发访问相关信息，等缺陷。而<strong>文件</strong>是对<strong>磁盘</strong>的建模，可以实现长期存储信息。</p><h3 id="设备，MMIO与操作系统对设备的控制"><a href="#设备，MMIO与操作系统对设备的控制" class="headerlink" title="设备，MMIO与操作系统对设备的控制"></a>设备，MMIO与操作系统对设备的控制</h3><ul><li><p>CPU（程序） 通过读写设备上的寄存器来和设备进行通信</p></li><li><p>MIPS 体系结构使用 <strong>MMIO（内存映射 IO）</strong>机制访问设备寄存器</p><ul><li>MMIO 使用不同的物理内存地址给设备寄存器编址。这种编址方式将一部分对物理内存的访问”重定向”到设备地址空间中, CPU尝试访问这部分物理内存的时候, 实际上最终是访问了相应的设备</li></ul></li><li>MIPS 体系结构中程序需要通过 KSEG1 段访问不可被缓存的外设</li><li>优点：可以通过和访问内存相同的方式进行对外设的访问，简化编程接口；可以直接访问外设寄存器，无需中间层来进行访问。</li></ul><p><img src="https://s2.loli.net/2023/05/07/RPm8qQxsATonCrc.png" alt="image-20230507094110821"></p><p>以下是 GXemul的仿真设备的说明：</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>consoles</td><td>0x10000000</td><td>A simple console device, for writing characters to the controlling terminal and receiving keypresses.</td></tr><tr><td>disk</td><td>0x13000000</td><td>Disk controller, which can read from and write to emulated IDE disks. It does not use interrupts; read and write operations finish instantaneously.</td></tr><tr><td>rtc</td><td>0x15000000</td><td>A Real-Time Clock, used to retrieve the current time and to cause periodic interrupts.</td></tr></tbody></table></div><h3 id="IDE-磁盘驱动"><a href="#IDE-磁盘驱动" class="headerlink" title="IDE 磁盘驱动"></a>IDE 磁盘驱动</h3><p><strong>IDE磁盘驱动位于用户空间</strong>，用户态进程直接读写 kseg1 会引发错误，需要通过以下两个系统调用实现用户态读写设备。</p><h4 id="系统调用实现设备读写"><a href="#系统调用实现设备读写" class="headerlink" title="系统调用实现设备读写"></a>系统调用实现设备读写</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// va: 用户虚拟地址; pa: 设备的物理地址; len: 读写的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Exercise 5.1: Your code here. (1/2) */</span></span><br><span class="line"><span class="comment">// Step1: 检查虚拟地址和物理地址的有效性</span></span><br><span class="line"><span class="keyword">if</span> (is_illegal_va_range(va, len) || is_illegal_pa_range(pa, len)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Step2: 把 [va, va+len) 的数据复制到物理地址 pa 处（memcpy, KEG1）</span></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)(KSEG1 + pa), (<span class="type">void</span> *)va, len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span> &#123;</span><br><span class="line"><span class="comment">/* Exercise 5.1: Your code here. (2/2) */</span></span><br><span class="line"><span class="keyword">if</span> (is_illegal_va_range(va, len) || is_illegal_pa_range(pa, len)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)va, (<span class="type">void</span> *)(KSEG1 + pa), len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="磁盘用户态驱动程序"><a href="#磁盘用户态驱动程序" class="headerlink" title="磁盘用户态驱动程序"></a>磁盘用户态驱动程序</h4><p>扇区是磁盘读写的基本单位，在本实验中扇区大小为512字节。GXemul 提供的 Simulated IDE disk 的地址是 0x13000000。</p><p><img src="https://s2.loli.net/2023/05/07/GWUI8oCuD9fQFKe.png" alt="image-20230507102855190"></p><p>当需要从磁盘的指定位置读取一个扇区时，驱动程序会调用 ide_read 函数来讲磁盘中对应的 sector 的数据读到设备缓冲区中，读取流程如下：</p><p>​    遍历所有要读取的扇区，进行以下操作：</p><ol><li>设置 IDE disk 的 ID，即将 diskno 写入 0xB3000010；</li><li>将相对于磁盘起始位置的偏移量写入 0xB3000000，注意此处偏移量为 $curoff = begin + off$ 。</li><li>向内存 0xB3000020写入0表示磁盘开始读操作（若写入1，表示磁盘开始写操作）；</li><li>从 0xB3000030获取操作的状态返回值，若成功（非0），就将这个sector的数据从设备缓冲区（0xB3004000~0xB30041ff）中拷贝到目标位置（dst + off）。（写操作，需要先将数据放入设备缓存区，然后后向地址 0xB3000020 处写入 1 来启动操作，并从 0xB3000030 处获取写磁盘操作的返回值。）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diskno: disk的ID; secno: 起始扇区号; dst: 从磁盘读取的数据存储目标位置; nsecs: 读取的扇区数量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span> &#123;</span><br><span class="line">u_int begin = secno * BY2SECT; <span class="comment">// 每个扇区512字节</span></span><br><span class="line">u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line"><span class="type">uint32_t</span> temp = diskno;</span><br><span class="line">u_int curoff = begin + off; <span class="comment">// 偏移量</span></span><br><span class="line"><span class="comment">/* Exercise 5.3: Your code here. (1/2) */</span></span><br><span class="line"><span class="comment">// Step1: 设置下一次读操作的磁盘编号</span></span><br><span class="line">panic_on(syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS + DEV_DISK_ID, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line"><span class="comment">// Step2: 设置下一次读操作时的磁盘镜像偏移的字节数</span></span><br><span class="line">panic_on(syscall_write_dev(&amp;curoff, DEV_DISK_ADDRESS, <span class="keyword">sizeof</span>(u_int)));</span><br><span class="line">temp = DEV_DISK_OPERATION_READ;</span><br><span class="line"><span class="comment">// Step3: 写 0 开始读磁盘</span></span><br><span class="line">panic_on(syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS + DEV_DISK_START_OPERATION, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line"><span class="comment">// Step4: 获取读操作的状态返回值</span></span><br><span class="line">panic_on(syscall_read_dev(&amp;temp, DEV_DISK_ADDRESS + DEV_DISK_STATUS, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line"><span class="keyword">if</span> (temp) &#123; <span class="comment">// 成功</span></span><br><span class="line"><span class="comment">// Step5: 将读到的数据放入目标虚拟地址</span></span><br><span class="line">panic_on(syscall_read_dev((dst + off), DEV_DISK_ADDRESS + DEV_DISK_BUFFER, DEV_DISK_BUFFER_LEN));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">user_panic(<span class="string">&quot;ide read failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *src, u_int nsecs)</span> &#123;</span><br><span class="line">u_int begin = secno * BY2SECT;</span><br><span class="line">u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line"><span class="type">uint32_t</span> temp = diskno;</span><br><span class="line">u_int curoff = begin + off;</span><br><span class="line"><span class="comment">/* Exercise 5.3: Your code here. (2/2) */</span></span><br><span class="line">panic_on(syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS + DEV_DISK_ID, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line">panic_on(syscall_write_dev(&amp;curoff, DEV_DISK_ADDRESS, <span class="keyword">sizeof</span>(u_int)));</span><br><span class="line">panic_on(syscall_write_dev((src + off), DEV_DISK_ADDRESS + DEV_DISK_BUFFER, DEV_DISK_BUFFER_LEN));</span><br><span class="line">temp = DEV_DISK_OPERATION_WRITE;</span><br><span class="line">panic_on(syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS + DEV_DISK_START_OPERATION, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line">panic_on(syscall_read_dev(&amp;temp, DEV_DISK_ADDRESS + DEV_DISK_STATUS, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line"><span class="keyword">if</span> (!temp)</span><br><span class="line">user_panic(<span class="string">&quot;ide write failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p><img src="https://s2.loli.net/2023/05/23/V1UAanI8XgbNFd7.png" alt="image-20230523001708002"></p><p><img src="https://s2.loli.net/2023/05/23/8FLaixvfu2mbkwB.png" alt="image-20230523001852036"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><blockquote><p>如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。 </p></blockquote><p>Cache 缓存采用的是写回（Write-Back）策略。当 CPU 需要写入数据时，Cache 缓存会将数据先写入 Cache 缓存中，并标记该数据已修改。当 Cache 缓存需要淘汰该数据时，才将数据写回到内存中。</p><p>引发的问题：1. 如果对设备控制寄存器进行了缓存，那么第一次引用的时候就把它放入了缓存，以后再对它的引用都是从高速缓存中取值。例如在设备读取操作中，当程序从设备读取数据时，若该数据已存在于Cache中，程序会直接从Cache读取，此时若设备的数据被其他程序或设备修改，就会导致数据不一致。2. 如果程序意外崩溃或者系统意外重启，Cache中的数据可能会丢失，导致设备数据丢失。</p><p>不同种类的设备：串口设备（Serial Port Device）是一种通过串行通信接口与计算机进行数据传输的外设设备。串口通信是一种基于一根数据线和一根时钟线进行数据传输的通信方式，它可以实现两台设备之间的数据传输和通信。串口设备传输速率较低，以字符为单位进行读写，更容易引发问题。而IDE磁盘出现错误的可能性较小。</p><h3 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h3><blockquote><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？ </p></blockquote><p>一个磁盘块大小为 4KB，一个文件控制块大小为256B，则一个磁盘块最多能存储16个文件控制块。文件系统支持的单个文件最大为4MB。一个目录下最多有1024个磁盘块，可以存储4MB内容，最多有16K个文件。</p><h3 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h3><blockquote><p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？ </p></blockquote><p>$0x50000000-0x10000000=0x40000000, 0x40000000B = 1GB$</p><h3 id="5-4"><a href="#5-4" class="headerlink" title="5.4"></a>5.4</h3><blockquote><p>在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。 </p></blockquote><p>fs/serv,h <code>PTE_DIRTY</code> : 标记缓存在虚拟内存空间的磁盘块是否被修改。</p><p>fs.h <code>FILE2BLK (BY2BLK / sizeof(struct File))</code> : 一个磁盘块可以存储的文件结构数。</p><p>fs.h <code>BY2BLK</code> : 一个磁盘块大小</p><p>fs.h <code>BIT2BLK</code> : 空闲磁盘块的位图标记</p><p>fs.h <code>NINDIRECT</code> :  文件指向的间接磁盘块中块指针的数量</p><p>fs.h <code>MAXFILESIZE</code> : 文件最大大小</p><p>fs.h <code>BY2FILE</code> : 文件结构体的大小</p><h3 id="5-5"><a href="#5-5" class="headerlink" title="5.5"></a>5.5</h3><blockquote><p>在 Lab4“系统调用与 fork”的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。 </p></blockquote><p>直接对 test lab=5_4 进行修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">int</span> fdnum;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = open(<span class="string">&quot;/newmotd&quot;</span>, O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;open /newmotd: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">fdnum = r;</span><br><span class="line">debugf(<span class="string">&quot;open is good\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">n = read(fdnum, buf, <span class="number">5</span>);</span><br><span class="line">debugf(<span class="string">&quot;[child] buffer is \&#x27;%s\&#x27;\n&quot;</span>, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">n = read(fdnum, buf, <span class="number">5</span>);</span><br><span class="line">debugf(<span class="string">&quot;[father] buffer is \&#x27;%s\&#x27;\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.loli.net/2023/05/22/ylULfRNwoHnt4xm.png" alt="image-20230522170343963"></p><p>说明父子进程共享文件描述符和定位指针。</p><h3 id="5-6"><a href="#5-6" class="headerlink" title="5.6"></a>5.6</h3><blockquote><p>请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。 </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件控制块：文件系统服务进程，包括磁盘驱动程序和文件系统的基本函数等，对应磁盘上的物理实体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span> </span><br><span class="line"><span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line"><span class="type">uint32_t</span> f_size; <span class="comment">// file size in bytes</span></span><br><span class="line"><span class="type">uint32_t</span> f_type; <span class="comment">// file type</span></span><br><span class="line"><span class="type">uint32_t</span> f_direct[NDIRECT];<span class="comment">// / 文件的直接指针，记录文件的数据块在磁盘上的位置，每个文件控制块设有 10 个直接指针 4KB*10</span></span><br><span class="line"><span class="type">uint32_t</span> f_indirect;<span class="comment">//指向间接磁盘块，存储指向文件内容的磁盘块的指针，不适用前10个指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// the pointer to the dir where this file is in, valid only in memory. 指向文件所属的文件目录</span></span><br><span class="line"><span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];<span class="comment">//为了让整数个文件结构体占用一个磁盘块，填充结构体中剩下的字节。</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));<span class="comment">//编译器将该结构体按4字节对齐，并且取消结构体的填充字节，使结构体大小紧凑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件描述符：允许用户程序使用统一的接口，抽象地操作磁盘文件系统中的文件，以及控制台和管道等虚拟的文件。单纯的内存数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">u_int fd_dev_id; <span class="comment">// 该文件对应的设备</span></span><br><span class="line">u_int fd_offset; <span class="comment">// 读写偏移量</span></span><br><span class="line">u_int fd_omode; <span class="comment">// 允许用户进程对文件的操作权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单纯的内存数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span> <span class="comment">// 文件描述符</span></span><br><span class="line">u_int f_fileid; <span class="comment">// 文件系统为打开的文件进行的编号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span> <span class="comment">// 对应文件的文件控制块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h3><blockquote><p>图5.7中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</p></blockquote><p><img src="https://s2.loli.net/2023/05/14/QmryVkCSP9scw3J.png" alt="image-20230514211928154"></p><p>实现箭头表示调用另一个程序中的函数，虚线表示获取调用返回值。</p><p>通过 ipc_send()</p><h2 id="课上"><a href="#课上" class="headerlink" title="课上"></a>课上</h2><p>lab5-2-exam 卡在了 openat 函数忘记 fd_alloc ，等 de 完这个 bug 后来不及写 extra 了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA OO Unit4 UML模型的验证与测试</title>
      <link href="/2023/06/18/OO-unit4/"/>
      <url>/2023/06/18/OO-unit4/</url>
      
        <content type="html"><![CDATA[<h2 id="StarUML-使用"><a href="#StarUML-使用" class="headerlink" title="StarUML 使用"></a>StarUML 使用</h2><blockquote><p>统一建模语言（UML）是一种提供针对性、分离的结构与行为描述手段而且可以将描述元素整合起来的语言。</p></blockquote><p>UML 可以通过多种描述视角提供语法明确、语义清晰的可视化图示语言，相对成熟。在复杂大型项目中可使用 UML 建立可视化模型来方便开发人员和用户之间的交流及系统维护。</p><p>本单元作业要求我们实现图书馆系统设计的类图、状态图和顺序图。以下仅简单描述我在使用 StarUML 完成作业时遇到的问题：</p><ol><li>作为初学者使用 StarUML 较为常见的问题：删除某个元素时 <code>delete</code> 表示仅在 diagram 中不显示，完全删除需要 <code>delete from model</code>。</li><li>绘制状态图时，在某个 transition 中添加 trigger，需要右击 transition 后 add，并修改 trigger 的 name。<img src="https://s2.loli.net/2023/06/18/87k9LVti5TRnzX6.png" alt="image-20230617194815605"></li><li>绘制顺序图时，需要在 Lifeline 相应的 role 里修改 type 属性 。<img src="https://s2.loli.net/2023/06/17/EWnVx2RGrXMa7CL.png" alt="image-20230617195041769"></li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><strong>实现一个图书馆模拟系统</strong></p><p>hw13：</p><ul><li>三类借阅和预定规则不同的书籍</li><li>图书馆内有五类 staff：借还管理员（负责B类书的借还和书籍损坏丢失的惩罚）、自助机器（查询余书，C类书籍的借还）、预定管理员（负责登记预定和发放预定的书籍）、整理管理员（每过三日整理管理员手中的书并送给预定管理员需要的书）、后勤处（修复书籍）。</li></ul><p>hw14迭代：</p><ul><li>校际借阅（确认需要校际借阅的书籍，处理校际借阅中书籍的运输、接收和发放工作）</li><li>书籍加购（确认购书清单）</li></ul><p>hw15迭代：</p><ul><li>图书借阅期限，逾期归还会被惩罚</li></ul><h2 id="正向建模与开发"><a href="#正向建模与开发" class="headerlink" title="正向建模与开发"></a>正向建模与开发</h2><p>上述进行了一个总体的需求分析，然而项目需求中还有许多繁琐、细节性的逻辑结构需要梳理，需要引入基于UML的正向建模。正向建模要求我们进行透彻的需求分析并通过UML可视化模型呈现，学习模型化设计思维方式，有助于我们理清需求、设计、实现层次的结构和行为：通过类图按数据和行为提取抽象形成抽象层次结构，通过顺序图确定哪些对象参与交互及对象需提供的操作从而识别类之间的关联关系，通过状态图进一步完善类的行为，在这个过程中建立了关联层次，实现层次设计。以下是本单元中我基于UML的正向建模流程：</p><p><img src="https://s2.loli.net/2023/06/17/ryvAga4PdzUL8DQ.png" alt="image-20230617223218230"></p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p><img src="https://s2.loli.net/2023/06/17/FqMtTnk5l6cjS2p.png" alt="image-20230617224419946"></p><p>以下为我的分层设计模型：</p><p><img src="https://s2.loli.net/2023/06/17/yr8bh9BsgwW3ZEt.png" alt="image-20230617233307178"></p><ol><li>按数据和行为对题目提取抽象，确定类的个数和职责。bookshelf、student、book为容器类，6个staff、library、library network是控制策略类。</li><li>按数据管理或从属层次建立关联结构，按照行为实施层次建立分层设计。library network 管理了 library池子，library 管理了6类staff、bookshelf 和 students 池子。</li><li>按照对象的交互和状态的转移设计设计类的行为。比如说某个学生发出借书请求，首先在 library network 查找相应 library 并调用其 handleRequest 方法，self-service machine 查询图书馆书架上是否有余书，若有，borrowing and returning librarian 或 self-service machine 判断其是否能借阅，若能借阅，则书成功被该同学借走。</li><li>通过对比最终的代码设计和UML模型设计之间的追踪关系，实现程序前的设计和程序还是比较契合的，当然程序实现后还是需要对UML模型进行一些改动。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本单元设计中我深刻感受到了正向建模的重要性，本单元的需求是细致繁复的，考验逻辑和抽象能力，比如说有些行为存在相似性，如何抽象设计降低代码复杂度是比较重要的一个问题。在最开始设计的时候，我只是在纸上画了一个粗略的草图，没有完全理清关系，导致类的职责不明确，增加了耦合性。另外在本单元设计中我没有抽象出一个功能输出类是比较可惜的，降低了代码的美观性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Object Oriented </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab6</title>
      <link href="/2023/05/21/Lab6/"/>
      <url>/2023/05/21/Lab6/</url>
      
        <content type="html"><![CDATA[<p><strong>Keywords：管道，shell</strong></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>共享内存和管道都是进程间通信（IPC）的方式。管道分为有名管道（可以在任意两个进程之间通信）和匿名管道（只能在具有公共祖先的进程之间使用，通常是在父子进程之间）。</p><p><em>MOS实验中仅要求实现匿名管道</em></p><h3 id="Unix-中的匿名管道"><a href="#Unix-中的匿名管道" class="headerlink" title="Unix 中的匿名管道"></a>Unix 中的匿名管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>在 Unix 中，管道由 int pipe(int fd[2]) 函数创建，成功创建管道返回 0，参数中的 fd用来保存读写端的文件描述符，fd[0] 对应读端，fd[1] 对应写端。通常，调用 pipe 的进程接着调用 fork，这样就创建了从父进程到子进程（或反向）的IPC通道。</p><p>匿名管道特点：</p><ol><li>数据单向流动，具有固定的读端和写端</li><li>只能用于具有公共祖先的进程之间通信，实现依赖于父子进程文件共享</li><li>是一种只存在于内存中的文件。父进程调用 pipe函数时，会打开两个新的<u>文件描述符</u>：一个表示只读端，另一个表示只写端，两个描述符都映射到了<u>同一片内存区域</u>。在 fork 的配合下，子进程复制父进程的两个文件描述符，从而在父子进程间形成了四个（父子各拥有一读一写）指向<u>同一片内存区域的文件描述符</u>，父子进程可根据需要关掉自己不用的一个，从而实现父子进程间的单向通信管道，这也是匿名管道只能用在具有亲缘关系的进程间通信的原因。</li></ol><h3 id="MOS-中-pipe-的实现"><a href="#MOS-中-pipe-的实现" class="headerlink" title="MOS 中 pipe 的实现"></a>MOS 中 pipe 的实现</h3><p>保证负责父子进程通过管道访问的内存相同：在 pipe 中，首先分配两个文件描述符 fd0 和 fd1 并为其分配空间，然后给 fd0 对应的虚拟地址分配一页物理内存，再将 fd1 对应的虚拟地址映射到这一页物理内存。</p><p><code>PTE_LIBRARY</code> ：共享页面是具有权限位 <strong>PTE_LIBRARY</strong> 的页面，需要保持共享可写的状态，使得父子进程对其进行修改的结果相互可见。当父子进程试图写共享页面时，直接在该页面上进行写操作即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pfd[<span class="number">2</span>])</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">void</span> *va;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd0</span>, *<span class="title">fd1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 1: Allocate the file descriptors. */</span></span><br><span class="line"><span class="comment">/* 注意 fd_alloc 函数仅找到一个未使用的文件描述符，并返回对应的虚拟地址，</span></span><br><span class="line"><span class="comment">依赖于调用者在调用fd_alloc之后负责分配物理内存。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> ((r = fd_alloc(&amp;fd0)) &lt; <span class="number">0</span> || (r = syscall_mem_alloc(<span class="number">0</span>, fd0, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = fd_alloc(&amp;fd1)) &lt; <span class="number">0</span> || (r = syscall_mem_alloc(<span class="number">0</span>, fd1, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> err1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 2: Allocate and map the page for the &#x27;Pipe&#x27; structure. */</span></span><br><span class="line"><span class="comment">// 给 fd0 对应的虚拟地址分配一页物理内存</span></span><br><span class="line">va = fd2data(fd0);</span><br><span class="line"><span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, (<span class="type">void</span> *)va, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 fd1 对应的虚拟地址映射到这一页物理内存</span></span><br><span class="line"><span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)va, <span class="number">0</span>, (<span class="type">void</span> *)fd2data(fd1), PTE_D | PTE_LIBRARY)) &lt;</span><br><span class="line">    <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> err3;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管道的读写"><a href="#管道的读写" class="headerlink" title="管道的读写"></a>管道的读写</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span> &#123;</span></span><br><span class="line"><span class="comment">// 下一个将要从管道读的数据的位置（读者更新）</span></span><br><span class="line">u_int p_rpos;       <span class="comment">// read position</span></span><br><span class="line"><span class="comment">// 下一个将要向管道写的数据的位置（写者更新）</span></span><br><span class="line">u_int p_wpos;       <span class="comment">// write position</span></span><br><span class="line"><span class="comment">// 32B的缓冲区（环形缓冲区）</span></span><br><span class="line">u_char p_buf[BY2PIPE]; <span class="comment">// data buffer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>读者在从管道读取大小不超过 n 字节的数据时，拷贝 <code>p_buf[p_rpos%BY2PIPE]</code> 的数据，然后 p_rpos++。注意当缓冲区此时还未写入数据（即管道数据为空，即 p_rpos &gt;= p_wpos）时，若写者进程结束则return，否则进程切换到写者运行。</p><p>写者在向管道写入数据时，将数据存入 <code>p_buf[p_wpos%BY2PIPE]</code> ，然后 p_wpos++。注意当缓冲区满溢（即 p_wpos - p_rpos &gt;= BY2PIPE）时，若写者进程结束则return，否则进程切换到读者运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *vbuf, u_int n, u_int offset)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">char</span> *rbuf;</span><br><span class="line"></span><br><span class="line">p = (<span class="keyword">struct</span> Pipe *)fd2data(fd);</span><br><span class="line">rbuf = (<span class="type">char</span> *)vbuf;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;p_rpos &gt;= p-&gt;p_wpos) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> || _pipe_is_closed(fd, p)) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">syscall_yield();</span><br><span class="line">&#125;</span><br><span class="line">rbuf[i] = p-&gt;p_buf[p-&gt;p_rpos++ % BY2PIPE];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">user_panic(<span class="string">&quot;pipe_read not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *vbuf, u_int n, u_int offset)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">char</span> *wbuf;</span><br><span class="line"></span><br><span class="line">p = (<span class="keyword">struct</span> Pipe *)fd2data(fd);</span><br><span class="line">wbuf = (<span class="type">char</span> *)vbuf;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;p_wpos - p-&gt;p_rpos &gt;= BY2PIPE) &#123;</span><br><span class="line"><span class="keyword">if</span> (_pipe_is_closed(fd, p)) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">syscall_yield();</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;p_buf[p-&gt;p_wpos++ % BY2PIPE] = wbuf[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">user_panic(<span class="string">&quot;pipe_write not implemented&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断管道一端是否关闭"><a href="#判断管道一端是否关闭" class="headerlink" title="判断管道一端是否关闭"></a>判断管道一端是否关闭</h5><p><code>static int _pipe_is_closed(struct Fd *fd, struct Pipe *p)</code> 判断管道的读者或写者是否已关闭。</p><p><em>原理见教程 P144。</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _pipe_is_closed(<span class="keyword">struct</span> Fd *fd, <span class="keyword">struct</span> Pipe *p) &#123;</span><br><span class="line"><span class="type">int</span> fd_ref, pipe_ref, runs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步读</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">runs = env-&gt;env_runs;</span><br><span class="line">fd_ref = pageref(fd); <span class="comment">// pageref 查询虚拟地址对应的实际物理页，返回其 pp_ref 变量的值</span></span><br><span class="line">pipe_ref = pageref(p);</span><br><span class="line">&#125; <span class="keyword">while</span> (runs != env-&gt;env_runs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fd_ref == pipe_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在我们的 MOS 操作系统中，只有 syscall_ 开头的系统调用函数是原子操作，其他所有包括 fork 这些函数在运行时都是可能会被随时打断</p></blockquote><p><u>对共享变量进行读写需要保证操作原子性</u>：</p><p><code>env_runs</code>是一个表示环境运行次数的计数器，每当发生一次上下文切换时，它的值就会增加。因此，如果在读取引用计数之前和之后，<code>env_runs</code>的值没有发生变化，那么可以认为在这期间环境没有发生切换或其他并发操作。</p><p>通过比较<code>env_runs</code>的值，可以实现一种简单的并发控制机制。如果在读取引用计数之前和之后的<code>env_runs</code>值不同，说明期间发生了环境切换，可能有其他线程或进程同时进行了对管道的读写操作，因此需要重新读取引用计数。</p><p>这种简单的机制并不是绝对可靠的，因为在某些情况下，环境可能会发生多次切换，而这段代码只能检测到最后一次切换。但在大多数情况下，这种机制已经足够满足需求，并能减少竞态条件和数据不一致性的发生概率。如果需要更精确的并发控制，可能需要使用更复杂的同步机制，如互斥锁或原子操作。</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>——实现命令行式 shell</p><ul><li>解析命令：分析命令的基本单元——特殊符号或单词，解析用户输入的命令</li><li>执行命令：调用spawn产生子进程并装载命令对应的ELF文件，子进程执行命令，父进程等待子进程执行结束后，结束进程。</li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><blockquote><p>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？ </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fildes[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">status = pipe(fildes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == <span class="number">-1</span> ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">close(fildes[<span class="number">0</span>]); <span class="comment">/* 关闭不用的读端 */</span></span><br><span class="line">            write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">close(fildes[<span class="number">1</span>]); <span class="comment">/* 读取结束，关闭写端 */</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            close(fildes[<span class="number">1</span>]); <span class="comment">/* 关闭不用的写端 */</span></span><br><span class="line">            read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child-process read:%s&quot;</span>,buf);</span><br><span class="line">            close(fildes[<span class="number">1</span>]); <span class="comment">/* 读取结束，关闭读端 */</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><blockquote><p>上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/lib/fd.c 中的 dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？ </p></blockquote><p><code>dup</code> 函数功能是将一个文件描述符的内容映射到另一个文件描述符中。当我们将一个管道的读/写端对应的文件描述符映射到另一个文件描述符时，映射前 $pageref(fd0)=1,pageref(fd1)=1,pageref(pipe)=2$ ，若首先 map fd0 ，则 $pageref(fd0) = 2$ ，则 $pageref(fd0) == pageref(pipe)$ ，错误判断了写端已经关闭。</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><blockquote><p>阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。 </p></blockquote><p>非原子性操作是因为发生了进程切换。CPU通过定时器产生的时钟中断确定一个时间片结束，从而跳转到内核下的schedule函数判断是否需要切换进程。</p><p>阅读指导书P83对 SR 寄存器的描述，每当异常发生时，执行 syscall 指令，CPU 会把 KUc 和 IEc 的数值拷贝到 KUp 和 IEp。随后将 KUc 和 IEc 置为 0。KUc = 0 表示 CPU 当前运行在内核态下， IEc = 0 表示 CPU 当前关闭了中断，也就不会产生时钟中断，那么系统调用就都是原子操作的。</p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><blockquote><p>仔细阅读上面这段话，并思考下列问题</p><ul><li>按照上述说法控制 <strong>pipe_close</strong> 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</li><li>我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件内容。试想，如果要复制的是一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。</li></ul></blockquote><p>问题1：可以解决，在任何时刻 $pageref(fd) \leq pageref(pipe)$ ，所以先 unmap fd 就不会错误判断两者相等。更具体的分析在指导书 P146。</p><p>问题2：会出现类似问题，当我们将一个管道的读/写端对应的文件描述符映射到另一个文件描述符时，映射前 $pageref(fd0)=1,pageref(fd1)=1,pageref(pipe)=2$ ，若首先 map fd0 ，则 $pageref(fd0) = 2$ ，则 $pageref(fd0) == pageref(pipe)$ ，错误判断了写端已经关闭。</p><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><blockquote><p>思考以下三个问题。</p><ul><li>认真回看 Lab5 文件系统相关代码，弄清打开文件的过程。</li><li>回顾 Lab1 与 Lab3，思考如何读取并加载 ELF 文件。</li><li>在 Lab1 中我们介绍了 data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于 memsize 和 filesize ，我们在 Note1.3.4中也解释了它们的含义与特点。关于 Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。回顾 Lab3 并思考：elf_load_seg() 和 load_icode_mapper()函数是如何确保加载 ELF 文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回顾 elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的？</li></ul><p>下面给出一些对于上述问题的提示，以便大家更好地把握加载内核进程和加载用户进程的区别与联系，类比完成 spawn 函数。</p><p>关于第一个问题，在 Lab3 中我们创建进程，并且通过 ENV_CREATE(…) 在内核态加载了初始进程，而我们的 spawn 函数则是通过和文件系统交互，取得文件描述块，进而找到 ELF 在“硬盘”中的位置，进而读取。</p><p>关于第二个问题，各位已经在 Lab3 中填写了 load_icode 函数，实现了 ELF 可执行文件中读取数据并加载到内存空间，其中通过调用 elf_load_seg 函数来加载各个程序段。在 Lab3 中我们要填写 load_icode_mapper 回调函数，在内核态下加载 ELF 数据到内存空间；相应地，在 Lab6 中 spawn 函数也需要在用户态下使用系统调用为 ELF 数据分配空间。</p></blockquote><ul><li>打开文件的过程：<code>user/lib/file.c</code> 下的 <code>open</code> 函数接受文件路径 <code>path</code> 和 模式 <code>mode</code> 作为输入参数，先调用 <code>fd_alloc</code> 申请文件描述符，再调用 <code>fsipc_open</code> 向文件系统服务进程发送打开文件的请求， <code>fsipc</code> 向文件系统服务进程发送 IPC 请求，并等待响应。 文件系统服务进程收到请求后调用 <code>serve_open</code> 处理请求，<code>serve_open</code> 调用 <code>file_open</code> 打开路径并寻找到文件描述符。</li><li>读取并加载 ELF 文件：load_icode 函数负责加载可执行文件 binary 到进程 e 的内存中。每当 <code>elf_load_seg</code> 函数解析到一个需要加载到内存中的页面，会将有关的信息作为参数传递给回调函数，并由它完成单个页面的加载过程，而这里 <code>load_icode_mapper</code> 就是 <code>map_page</code> 的具体实现。</li><li>在 <code>elf_load_seg</code> 函数处理中，当该段在文件中的大小达不到为填入这段内容新分配的页面大小（即 <code>bin_size &lt; sgsize</code>）时，余下的部分用 0 来填充，即为 bss 段的数据赋了初值 0 。</li></ul><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><blockquote><p>通过阅读代码空白段的注释我们知道，将文件复制给标准输入或输出，需要我们将其 dup 到 0 或 1 号文件描述符 (fd)。那么问题来了：在哪步，0 和 1 被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。 </p></blockquote><p>在 <code>user/init.c</code> 中如下，将0号文件描述符映射到1号，相当于把控制台的输入输出缓冲区当做管道。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r = dup(<span class="number">0</span>, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;dup: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><blockquote><p>在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork一个子 shell，然后子 shell 去执行这条命令。</p><p>据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么Linux 的 cd 命令是内部命令而不是外部命令？ </p></blockquote><p>MOS中外部命令。</p><p>确保 cd 切换目录仅在当前进程发生，且子进程无法直接修改父进程的环境变量。</p><h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><blockquote><p>在你的 shell 中输入命令 ls.b | cat.b &gt; motd。</p><ul><li>请问你可以在你的 shell 中观察到几次 spawn ？分别对应哪个进程？</li><li>请问你可以在你的 shell 中观察到几次进程销毁？分别对应哪个进程？</li></ul></blockquote><p>观察到两次spawn。在 main 函数中，对于每次输入的命令，先 fork 出一个子进程处理命令，该子进程在运行runcmd时会调用一次 spawn；在执行管道时，fork出的子shell进程执行 “|” 后的命令时又进行了一次 spawn。==（notsure）==</p><p>观察到四次进程销毁，首先销毁处理管道时fork出的子shell进程在runcmd时的spawn产生的进程，其次销毁管道fork的子进程，然后销毁整条命令作为参数传入runcmd时spawn产生的进程，最后销毁在main函数进程fork出的子进程。</p><p><img src="https://s2.loli.net/2023/05/21/3bNofEhYmGK2B48.png" alt="image-20230521205126729"></p>]]></content>
      
      
      
        <tags>
            
            <tag> os 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab4</title>
      <link href="/2023/05/18/Lab4/"/>
      <url>/2023/05/18/Lab4/</url>
      
        <content type="html"><![CDATA[<p><strong>用户程序启动的流程</strong></p><p><code>user.lds</code>用户程序的链接脚本：加载 <code>.text</code>, <code>.data</code> , <code>.bss</code> 至 0x00400000，设定用户程序的入口为 <code>_start</code>。</p><p><code>entry.S</code>: <code>user\lib</code>，用户程序main函数运行时需要两个参数，跳转至<code>libmain</code>。</p><p><code>libmain</code>: <code>libos.c</code>，设置 <code>env</code> ，使得用户可以访问到当前进程的进程控制块；跳转至 <code>main</code> 主函数；<code>exit</code> 系统调用结束当前进程的运行。</p><h2 id="系统调用-8号异常"><a href="#系统调用-8号异常" class="headerlink" title="系统调用 - 8号异常"></a>系统调用 - 8号异常</h2><h3 id="系统调用过程"><a href="#系统调用过程" class="headerlink" title="系统调用过程"></a>系统调用过程</h3><h4 id="1-用户程序使用-syscall-接口"><a href="#1-用户程序使用-syscall-接口" class="headerlink" title="1. 用户程序使用 syscall_* 接口"></a>1. 用户程序使用 <code>syscall_*</code> 接口</h4><ol><li>用户程序调用 <code>syscall_*</code> 函数接口。</li><li><code>syscall_*</code>将实现系统调用所需的参数作为 <code>msyscall</code> 的传入参数，在调用 <code>msyscall</code> 时，会自动将参数（第一个参数为<strong>系统调用号</strong>）存入寄存器和用户栈（内核后续可以访问这些参数）。<em>此处的自动理解为存储过程编译器会自动编译为汇编代码，我们只需要在内核中显示地从保存的用户上下文中获取函数的参数</em></li><li><code>msyscall</code> 中 执行 <code>syscall</code> 指令使 CPU 陷入内核态完成系统调用；在返回用户态继续运行此函数时，执行 <code>jr ra</code> 指令返回到 <code>syscall_*</code> 函数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEAF(msyscall)</span><br><span class="line"><span class="comment">// 系统由此陷入内核态</span></span><br><span class="line">syscall</span><br><span class="line">jr ra</span><br><span class="line"><span class="title function_">END</span><span class="params">(msyscall)</span></span><br></pre></td></tr></table></figure><h4 id="2-异常入口与分发"><a href="#2-异常入口与分发" class="headerlink" title="2. 异常入口与分发"></a>2. 异常入口与分发</h4><p>用户态下执行 <code>syscall</code> 指令会触发异常，CPU 陷入内核态，从 0x80000080 (即 <code>.exc_gen_entry</code>所在位置) 开始取指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.section .text.exc_gen_entry</span><br><span class="line">exc_gen_entry:</span><br><span class="line"><span class="comment">// 将用户进程的上下文运行环境保存在内核栈中</span></span><br><span class="line">SAVE_ALL</span><br><span class="line">    <span class="comment">// 取出 CP0_CAUSE 中的异常码</span></span><br><span class="line">mfc0 t0, CP0_CAUSE</span><br><span class="line">andi t0, <span class="number">0x7c</span></span><br><span class="line">    <span class="comment">// 以异常码8为索引在 exception_handlers 数组中倒找对应的异常处理函数 handle_sys</span></span><br><span class="line">lw t0, exception_handlers(t0)</span><br><span class="line">    <span class="comment">// 跳转至相应异常处理函数处理用户的系统调用请求</span></span><br><span class="line">jr t0</span><br></pre></td></tr></table></figure><h4 id="3-内核处理系统调用请求"><a href="#3-内核处理系统调用请求" class="headerlink" title="3. 内核处理系统调用请求"></a>3. 内核处理系统调用请求</h4><p><code>handle_sys</code>核心逻辑位于 <code>do_syscall</code> 函数。当内核处理完系统调用请求后，调用 <code>ret_from_exception</code> 从内核态返回用户程序。</p><p>在 <code>kern/genex.S</code> 中用 <code>BUILD_HANDLER</code> 宏封装了 <code>handle_sys</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.macro BUILD_HANDLER exception handler</span><br><span class="line"><span class="title function_">NESTED</span><span class="params">(handle_\exception, TF_SIZE + <span class="number">8</span>, zero)</span></span><br><span class="line">move    a0, sp <span class="comment">// 作为 do_syscall 的传入参数</span></span><br><span class="line">addiu   sp, sp, -8</span><br><span class="line">jal     \handler</span><br><span class="line">addiu   sp, sp, 8</span><br><span class="line">j       ret_from_exception</span><br><span class="line"><span class="title function_">END</span><span class="params">(handle_\exception)</span></span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line"><span class="title function_">FEXPORT</span><span class="params">(ret_from_exception)</span></span><br><span class="line">RESTORE_SOME</span><br><span class="line">lw      k0, <span class="title function_">TF_EPC</span><span class="params">(sp)</span></span><br><span class="line">lw      sp, <span class="title function_">TF_REG29</span><span class="params">(sp)</span> <span class="comment">/* Deallocate stack */</span></span><br><span class="line">.<span class="built_in">set</span> noreorder</span><br><span class="line">jr      k0</span><br><span class="line">rfe <span class="comment">/*在上一条jr指令的延迟槽中执行，这样可以保证原子性*/</span></span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line"></span><br><span class="line"><span class="title function_">NESTED</span><span class="params">(handle_int, TF_SIZE, zero)</span></span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2</span><br><span class="line">andi    t1, t0, STATUS_IM4</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle other irqs</span></span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, <span class="params">(KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_INTERRUPT_ACK)</span></span><br><span class="line">li      a0, 0</span><br><span class="line">j       schedule</span><br><span class="line"><span class="title function_">END</span><span class="params">(handle_int)</span></span><br><span class="line"></span><br><span class="line">BUILD_HANDLER tlb do_tlb_refill</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB) || LAB &gt;= 4</span></span><br><span class="line">BUILD_HANDLER mod do_tlb_mod</span><br><span class="line">BUILD_HANDLER sys do_syscall</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">BUILD_HANDLER reserved do_reserved</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>C预处理器中的宏替换语法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> macro_name(parameter_list) replacement_text</span></span><br></pre></td></tr></table></figure><p>在这个代码片段中，<code>BUILD_HANDLER</code> 宏具有两个参数，<code>exception</code> 和 <code>handler</code>。它会将 <code>\handler</code> 替换为传递给宏的第二个参数，即对应的异常处理程序的名称。在代码中使用宏时，只需在宏名称后面加上括号，并在括号中传递参数即可。<code>\</code> 被用作宏替换文本中的转义符。当宏替换文本中需要使用 <code>\</code> 字符时，需要在它前面加上 <code>\</code> 转义符，以确保在宏替换时 <code>\</code> 能够正确地被处理。</p><p><strong>内核获取用户传递的参数</strong></p><p><code>do_syscall</code> 函数在处理系统调用请求时需要获得由用户进程传递的参数。</p><p>用户进程在调用 <code>msyscall</code> 时，已将这些参数存入 <code>a0</code> , <code>a1</code> , <code>a2</code> , <code>a3</code> 寄存器和用户栈中。内核处理系统调用请求时，CPU处于内核态，通用寄存器等现场环境发生了变化，堆栈指针也已指向了内核栈。借助内核栈中保存的用户进程上下文环境。观察 <code>SAVE_ALL</code> ，在保护用户态现场时 <code>sp</code> 减去了一个 <code>Trapframe</code> 结构体的空间大小，此时我们将用户进程现场保存在内核栈中范围为 <code>[sp, sp + sizeof(TrapFrame))</code> 的这一空间范围内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="comment">// tf：内核栈保存的用户进程现场</span></span><br><span class="line"><span class="type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int); <span class="comment">// 系统调用内核函数指针</span></span><br><span class="line"><span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>]; <span class="comment">// a0 系统调用号</span></span><br><span class="line"><span class="keyword">if</span> (sysno &lt; <span class="number">0</span> || sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 内核完成系统调用返回用户态时，将从内核栈保存到 `Trapframe` 结构体中恢复进程现场。</span></span><br><span class="line">    <span class="comment">// epc 修改前存放 msyscall 函数中 syscall 指令地址，修改后指向 msyscall 函数中 jr ra 指令</span></span><br><span class="line">tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 系统调用函数在 syscall_table 数组中以系统调用号作为索引存储</span></span><br><span class="line">func = syscall_table[sysno];</span><br><span class="line">u_int arg1 = tf-&gt;regs[<span class="number">5</span>];</span><br><span class="line">u_int arg2 = tf-&gt;regs[<span class="number">6</span>];</span><br><span class="line">u_int arg3 = tf-&gt;regs[<span class="number">7</span>];</span><br><span class="line">u_int arg4, arg5;</span><br><span class="line">arg4 = *(u_int *)(tf-&gt;regs[<span class="number">29</span>] + <span class="number">16</span>);</span><br><span class="line">arg5 = *(u_int *)(tf-&gt;regs[<span class="number">29</span>] + <span class="number">20</span>);</span><br><span class="line">tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5); <span class="comment">// 函数返回值写入 v0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在所有内核的syscall实现中，如果想修改用户进程从 syscall 返回后的用户现场，都需要修改内核栈中的 Trapframe 实现，而不是直接修改进程控制块的tf。</strong></p><p><img src="https://s2.loli.net/2023/05/18/svx5Y3Pb7SRyu9F.png" alt="image-20230423092019674"></p><h3 id="系统调用功能实现"><a href="#系统调用功能实现" class="headerlink" title="系统调用功能实现"></a>系统调用功能实现</h3><p>在内核处理进程发起的系统调用时，我们并没有切换地址空间（页目录地址），也不需要将进程上下文（Trapframe）保存到进程控制块中，只是切换到内核态下，执行了一些内核代码。</p><p><strong><code>envid2env</code> 函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">envid2env</span><span class="params">(u_int envid, <span class="keyword">struct</span> Env **penv, <span class="type">int</span> checkperm)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!envid) &#123;</span><br><span class="line">*penv = curenv;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">e = &amp;envs[ENVX(envid)];</span><br><span class="line"><span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 当 checkperm 为 1 时，e 必须满足 e 是当前进程 或 是当前进程的子进程。</span></span><br><span class="line"><span class="keyword">if</span> (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">&#125;</span><br><span class="line">*penv = e;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>envid2env</code> 函数中，如果 <code>checkperm</code> 不为零，那么函数需要检查调用者是否有足够的权限来操作指定的进程（<code>e</code>）。具体来说，如果 <code>e</code> 不是当前进程（<code>curenv</code>）或当前进程的直接子进程，那么就认为权限不足，返回 <code>-E_BAD_ENV</code> 错误。</p><h2 id="进程间通信（IPC"><a href="#进程间通信（IPC" class="headerlink" title="进程间通信（IPC)"></a>进程间通信（IPC)</h2><p>由于进程的地址空间之间是相互独立的，要想传递数据，我们就需要想办法把一个地址空间中的东西传给 另一个地址空间。因为所有的进程共享内核空间（主要为 kseg0)，我们可以借助<strong>内核空间</strong>来实现不同用户地址空间的数据交换。发送方进程使用系统调用将传递的数据存放在<strong>进程控制块</strong>中，接收方进程同样使用 系统调用在<strong>进程控制块</strong>中找到对应的数据，读取并返回。</p><h2 id="进程创建FORK"><a href="#进程创建FORK" class="headerlink" title="进程创建FORK"></a>进程创建FORK</h2><p><img src="https://s2.loli.net/2023/05/18/sUqF3Lf6TxtrZmE.png" alt="image-20230423111257874"></p><h3 id="写时复制机制"><a href="#写时复制机制" class="headerlink" title="写时复制机制"></a>写时复制机制</h3><p>在 fork 时，我们只需将地址空间中的所有可写页标记为写时复制页面（<code>PTE_COW = 1 &amp;&amp; PTE_D = 0</code>），使得在父进程或子进程对写时复制页面进行写入时，会触发 TLB Mod 页写入异常。操作系统在异常处理时，为当前进程试图写入的虚拟地址分配新的物理页面，并复制原页面的内容，最后再返回用户程序，对新分配的物理页面进行写入。</p><h4 id="页写入异常流程："><a href="#页写入异常流程：" class="headerlink" title="页写入异常流程："></a>页写入异常流程：</h4><p>当用户程序写入一个在 TLB 中被标记为不可写入（无 PTE_D）的页面时，MIPS 会陷入页写入异常（TLB Mod）。</p><ol><li>用户进程触发页写入异常，陷入到内核中的 handle_mod，再跳转到 do_tlb_mod 函数。</li><li>do_tlb_mod 函数负责将当前现场保存在异常处理栈中，并设置 a0 和 EPC 寄存器的值，使得从异常恢复后能够以异常处理栈中保存的现场（Trapframe）为参数，跳转到env_user_tlb_mod_entry 域存储的用户异常处理函数的地址。</li><li>从异常恢复到用户态，跳转到用户异常处理函数 <code>cow_entry</code> 中，由用户程序完成写时复制等自定义处理。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_tlb_mod</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line"><span class="comment">// 将栈指针指向异常处理栈</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP; <span class="comment">// UXSTACKTOP：异常处理栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将当前现场保存在异常处理栈中</span></span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">*(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;</span><br><span class="line">tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];</span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);</span><br><span class="line"><span class="comment">// 从异常恢复到用户态，跳转到用户异常处理函数中，由用户程序完成写时复制等自定义处理。</span></span><br><span class="line">tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户态下</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) cow_entry(<span class="keyword">struct</span> Trapframe *tf) &#123;</span><br><span class="line">    <span class="comment">// 获取触发 TLB Mod 的页面虚拟地址</span></span><br><span class="line">u_int va = tf-&gt;cp0_badvaddr;</span><br><span class="line">u_int perm;</span><br><span class="line">Pte pte = vpt[VPN(va)];</span><br><span class="line">perm = pte &amp; <span class="number">0xfff</span>;</span><br><span class="line">    <span class="comment">// 检查 va 对应的页是否为写时复制页面</span></span><br><span class="line"><span class="keyword">if</span> (!(perm &amp; PTE_COW)) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;cow_entry: &#x27;va&#x27; is not a copy-on-write page.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">perm = ((perm &amp; ~PTE_COW) | PTE_D);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    <span class="comment">// 分配一页物理页，暂时映射到虚拟地址 UCOW，更新权限</span></span><br><span class="line">panic_on(syscall_mem_alloc(<span class="number">0</span>, (<span class="type">void</span> *)UCOW, perm));</span><br><span class="line">    <span class="comment">// 复制页面内容到新页面</span></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)UCOW, (<span class="type">void</span> *)ROUNDDOWN(va, BY2PG), BY2PG);</span><br><span class="line">    <span class="comment">// 将新页面映射到虚拟地址 va</span></span><br><span class="line">panic_on(syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)UCOW, <span class="number">0</span>, va, perm));</span><br><span class="line">    <span class="comment">// 把虚拟地址 UCOW 的临时映射取消</span></span><br><span class="line">panic_on(syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)UCOW));</span><br><span class="line">     <span class="comment">//还原当前进程的上下文，恢复 TLB Mod 异常前的状态</span></span><br><span class="line"><span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">user_panic(<span class="string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">u_int child;</span><br><span class="line">u_int i;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// 父进程为自己注册 TLB Mod 异常处理函数</span></span><br><span class="line"><span class="keyword">if</span> (env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry) &#123;</span><br><span class="line">try(syscall_set_tlb_mod_entry(<span class="number">0</span>, cow_entry));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 创建子进程（暂时为 ENV_NOT_RUNNABLE 状态）</span></span><br><span class="line">    <span class="comment">// 父进程记录下子进程的 envid；子进程为自己的 env 变量赋值（libos.c）并返回 0</span></span><br><span class="line">child = syscall_exofork();</span><br><span class="line"><span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程，更新当前进程标识符并返回</span></span><br><span class="line">env = envs + ENVX(syscall_getenvid());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 父进程使用 duppage 将 USTACKTOP 以下的页面映射给子进程</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; USTACKTOP; i += BY2PG) &#123;</span><br><span class="line"><span class="keyword">if</span> ((vpd[i&gt;&gt;PDSHIFT] &amp; PTE_V) &amp;&amp; (vpt[i&gt;&gt;PGSHIFT] &amp; PTE_V))</span><br><span class="line">&#123;</span><br><span class="line">duppage(child, VPN(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 父进程为子进程注册 TLB Mod 异常处理函数 cow_entry（syscall_set_tlb_mod_entry）</span></span><br><span class="line">try(syscall_set_tlb_mod_entry(child, cow_entry));</span><br><span class="line">    <span class="comment">// 父进程将子进程的状态设置为 ENV_RUNNABLE，使子进程可以被调度开始运行（syscall_set_env_status）</span></span><br><span class="line">try(syscall_set_env_status(child, ENV_RUNNABLE));</span><br><span class="line">    <span class="comment">// 父进程返回子进程的 envid</span></span><br><span class="line"><span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_trapframe</span><span class="params">(u_int envid, <span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查 tf 是否处在合法的用户地址空间</span></span><br><span class="line"><span class="keyword">if</span> (is_illegal_va_range((u_long)tf, <span class="keyword">sizeof</span> *tf)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 获取目标进程的进程控制块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改当前正在运行的进程的 Trapframe，这通常发生在系统调用的处理函数中，例如在 do_syscall函数中，会调用 sys_set_trapframe 修改当前进程的 Trapframe，以便在系统调用返回时使用正确的上下文。</span></span><br><span class="line"><span class="keyword">if</span> (env == curenv) &#123;</span><br><span class="line">        <span class="comment">// 使用tf指向的Trapframe替换系统调用时的Trapframe</span></span><br><span class="line">*((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>) = *tf;</span><br><span class="line">        <span class="comment">//  返回 tf-&gt;regs[2] 而不是返回 0，因为 do_syscall 中我们会用返回值覆盖掉现场中的 regs[2]</span></span><br><span class="line"><span class="keyword">return</span> tf-&gt;regs[<span class="number">2</span>];</span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">// 修改另一个进程的 Trapframe，这通常发生在进程切换的时候，例如在 sched_yield 函数中，会调用 sys_set_trapframe 修改目标进程的 Trapframe，以便在切换回该进程时能够正确地恢复该进程的上下文。</span></span><br><span class="line">    <span class="comment">/*此处存疑！！！*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 tf 指向的 Trapframe 替换该进程控制块中存储的 Trapframe</span></span><br><span class="line">env-&gt;env_tf = *tf;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_tlb_mod_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">// 通过进程的 envid 获取对应的进程控制块</span></span><br><span class="line">try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 在进程控制块中设置 TLB Mod 异常处理函数为 func</span></span><br><span class="line">env-&gt;env_user_tlb_mod_entry = func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="comment">// 创建子进程，并在新创建的进程控制块 e 中记录父进程的 envid</span></span><br><span class="line">panic_on(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line"><span class="comment">// 设置子进程的 Trapframe 为父进程系统调用时的 Trapframe</span></span><br><span class="line">    <span class="comment">// 父进程系统调用时的上下文存储在内核栈中，内核栈此时只有父进程的 Trapframe</span></span><br><span class="line">e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 将子进程的 Trapframe 中的 v0 寄存器值设为 0（如同子进程返回 0）</span></span><br><span class="line">e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置子进程为不可运行状态（ENV_NOT_RUNNABLE）</span></span><br><span class="line">e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    <span class="comment">// 设置子进程的优先级与当前进程相同</span></span><br><span class="line">e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line"><span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">duppage</span><span class="params">(u_int envid, u_int vpn)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">u_int addr;</span><br><span class="line">u_int perm;</span><br><span class="line">    <span class="comment">// 通过 vpn 获取对应虚拟页的虚拟地址 addr</span></span><br><span class="line">addr = vpn &lt;&lt; PGSHIFT;</span><br><span class="line">    <span class="comment">// 获取父进程对应虚拟页的权限</span></span><br><span class="line">    Pte pte = vpt[vpn];</span><br><span class="line">perm = pte &amp; <span class="number">0xfff</span>; <span class="comment">// 取出低12位</span></span><br><span class="line"><span class="comment">// 根据父进程对应虚拟页的权限，进行不同的映射操作</span></span><br><span class="line">    <span class="comment">// 若页面不可写、或为共享页面时，不需要进行写时复制保护，保持原有权限映射给子进程</span></span><br><span class="line"><span class="comment">// 若页面已经为写时复制页面，保持原有权限映射给子进程</span></span><br><span class="line"><span class="comment">// 其它情况下，需要对页面加上写时复制保护（PTE_COW）、去掉可写权限（PTE_D）并映射给子进程</span></span><br><span class="line"><span class="keyword">if</span> ((perm &amp; PTE_D) &amp;&amp; !(perm &amp; PTE_LIBRARY) &amp;&amp; !(perm &amp; PTE_COW)) &#123;</span><br><span class="line">panic_on(syscall_mem_map(<span class="number">0</span>, addr, envid, addr, (perm &amp; ~PTE_D) | PTE_COW));</span><br><span class="line">panic_on(syscall_mem_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, (perm &amp; ~PTE_D) | PTE_COW));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">panic_on(syscall_mem_map(<span class="number">0</span>, addr, envid, addr, perm));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_env_status</span><span class="params">(u_int envid, u_int status)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"><span class="comment">// 若 status 不为 ENV_RUNNABLE 或 ENV_NOT_RUNNABLE 则返回 -E_INVAL</span></span><br><span class="line"><span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line"><span class="keyword">return</span> - E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 envid 获取目标的进程的进程控制块</span></span><br><span class="line">try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// 根据进程状态的切换，维护 env_sched_list</span></span><br><span class="line"><span class="comment">// 若进程从 RUNNABLE 变为 NOT_RUNNABLE 则需要从 env_sched_list 移除</span></span><br><span class="line"><span class="comment">// 反之则需要添加进 env_sched_list 的尾部</span></span><br><span class="line"><span class="keyword">if</span> (env-&gt;env_status == ENV_RUNNABLE &amp;&amp; status == ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">TAILQ_REMOVE(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (env-&gt;env_status == ENV_NOT_RUNNABLE &amp;&amp; status == ENV_RUNNABLE) &#123;</span><br><span class="line">TAILQ_INSERT_HEAD(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line">env-&gt;env_status = status;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1-系统调用的实现"><a href="#1-系统调用的实现" class="headerlink" title="1. 系统调用的实现"></a>1. 系统调用的实现</h3><ol><li><blockquote><p>内核在保存现场的时候是如何避免破坏通用寄存器的？</p></blockquote><ul><li><code>stackframe.h</code> 定义了 <code>SAVE_ALL</code> 和 <code>RESTORE_SOME</code> 宏用于保存和恢复CPU寄存器。在 <code>SAVE_ALL</code> 宏中，首先用 <code>k0</code> 暂存栈指针（<code>k0</code>,<code>k1</code>仅内核态下使用，允许异常处理程序使用<code>k0</code>且无需保存或恢复其值），然后对 <code>sp</code> 操作确定保存用户上下文环境的内核栈空间。先将之前暂存的 <code>k0</code> 存入，再依次将 CP0 寄存器、HI/LO寄存器和通用寄存器存入。</li></ul></li><li><blockquote><p>系统陷入内核调用后可以直接从当时的 a0-a3 参数寄存器中得到用户调用 msyscall留下的信息吗？</p></blockquote><ul><li>不可以，系统陷入内核态后，进行上下文环境切换，上述值应该从内核栈中获取。</li></ul></li><li><blockquote><p>我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样的参数的？</p></blockquote><ul><li>根据 MIPS 调用规范，用户进程再调用 msyscall 时，已将这些参数存入 a0 - a3 寄存器和用户栈中。由于内核处理系统调用请求时，CPU处于内核态，需要从内核栈中保存的用户进程上下文环境获取这些参数。</li></ul></li><li><blockquote><p>内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变化是什么？</p></blockquote><ul><li>cp0_epc + 4, epc 修改前存放 msyscall 函数中 syscall 指令地址，修改后指向 msyscall 函数中 jr ra 指令。将func函数返回值写入 v0 寄存器，使得在恢复用户进程上下文环境后，用户程序可以从该寄存器读取 msyscall 的返回值。</li></ul></li></ol><h3 id="2-envid2env-的实现"><a href="#2-envid2env-的实现" class="headerlink" title="2. envid2env 的实现"></a>2. envid2env 的实现</h3><blockquote><p>思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid的情况？如果没有这步判断会发生什么情况？ </p></blockquote><p>观察生成新进程的 <code>env_id</code> 的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG2NENV 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NENV (1 &lt;&lt; LOG2NENV)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENVX(envid) ((envid) &amp; (NENV - 1))</span></span><br><span class="line">u_int <span class="title function_">mkenvid</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line"><span class="type">static</span> u_int i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ((++i) &lt;&lt; (<span class="number">1</span> + LOG2NENV)) | (e - envs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>envid != 0</code> 时，通过 <code>e = &amp;envs[ENVX(envid)]</code> 获取当前进程，<code>ENVX</code> 宏取 envid 的低10位，没有对高位进行判断。当查询的 envid 为错误的进程 id，比如 <code>envid = 0xc00</code>，而 <code>envs[0].env_id = 0x400</code>，如果没有这个判断，<code>*penv = &amp;envs[0]</code> ，这显然是不正确的。</p><h3 id="3-mkenvid-函数细节"><a href="#3-mkenvid-函数细节" class="headerlink" title="3. mkenvid 函数细节"></a>3. mkenvid 函数细节</h3><blockquote><p>请回顾 kern/env.c 文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与envid2env() 函数的行为进行解释。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u_int <span class="title function_">mkenvid</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line"><span class="type">static</span> u_int i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ((++i) &lt;&lt; (<span class="number">1</span> + LOG2NENV)) | (e - envs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在系统调用和 IPC部分的实现中，常常需要使用 <code>envid2env</code> 函数来查找进程标识符，而在 <code>envid2env</code> 函数中我们将 <code>envid==0</code> 的含义定义为返回当前进程。观察函数即可发现其通过 <code>((++i) &lt;&lt; (1 + LOG2NENV))</code> 保证该函数不会返回0，避免冲突。</p><h3 id="4-fork的返回结果"><a href="#4-fork的返回结果" class="headerlink" title="4. fork的返回结果"></a>4. fork的返回结果</h3><blockquote><p>关于 fork 函数的两个返回值，下面说法正确的是：</p><p>A、fork 在父进程中被调用两次，产生两个返回值</p><p>B、fork 在两个进程中分别被调用一次，产生两个不同的返回值</p><p>C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值</p><p>D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值</p></blockquote><p>C</p><h3 id="5-用户空间的保护"><a href="#5-用户空间的保护" class="headerlink" title="5. 用户空间的保护"></a>5. 用户空间的保护</h3><blockquote><p>我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 kern/env.c 中 env_init 函数进行的页面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考。 </p></blockquote><p>不同权限位的页使用情况处理：</p><ul><li>只读页面：对于不具有 PTE_D 权限位的页面。按照相同权限（只读）映射给子进程即可。</li><li>写时复制页面：即具有 PTE_COW 权限位的页面。这类页面是之前的 fork 时 duppage 的结果，且在本次 fork 前必然未被写入过。按照相同权限（写时复制）映射给子进程即可。</li><li>共享页面：即具有 PTE_LIBRARY 权限位的页面。这类页面需要保持共享可写的状态，即在父子进程中映射到相同的物理页，使对其进行修改的结果相互可见。按照相同权限（共享）映射给子进程即可。</li><li>可写页面：即具有 PTE_D 权限位，且不符合以上特殊情况的页面。这类页面需要在父进程和子进程的页表项中都使用 PTE_COW 权限位进行保护。</li></ul><h3 id="6-vpt-和-vpd-的使用"><a href="#6-vpt-和-vpd-的使用" class="headerlink" title="6. vpt 和 vpd 的使用"></a>6. vpt 和 vpd 的使用</h3><ol><li><blockquote><p>vpt 和 vpd 的作用是什么？怎样使用它们？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT) <span class="comment">// 指向当前进程页表的指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT))) <span class="comment">// 指向当前进程页目录表的指针</span></span></span><br><span class="line"><span class="comment">//volatile 提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据</span></span><br><span class="line">Pde pde = vpd[va &gt;&gt; PDSHIFT];</span><br><span class="line">Pte pte = vpt[va &gt;&gt; PGSHIFT];</span><br><span class="line"><span class="comment">// 通过上述操作访问相应的页目录项和页表项</span></span><br></pre></td></tr></table></figure></li><li><blockquote><p>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</p><p>它们是如何体现自映射设计的？</p></blockquote><p>观察 <code>env.c</code> 中的 <code>env_setup_vm</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">try(page_alloc(&amp;p)); <span class="comment">// 页目录</span></span><br><span class="line">p-&gt;pp_ref ++;</span><br><span class="line">e-&gt;env_pgdir = (Pde *)page2kva(p);</span><br><span class="line">    <span class="comment">// 将 base_pgdir页目录表中从UTOP 到 UVPT 的页目录项拷贝到进程页目录表中的相同位置，那么用户程序就可以读取到内核的 pages 和 envs 数据。</span></span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP),</span><br><span class="line">       <span class="keyword">sizeof</span>(Pde) * (PDX(UVPT) - PDX(UTOP)));</span><br><span class="line">    <span class="comment">// 将进程页目录表中 UVPT 所对应的页目录项设置成一个自映射的页表，将自身映射到UVPT所在的虚拟地址上。（其实我还是不理解这个自映射）</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><blockquote><p>进程能够通过这种方式来修改自己的页表项吗？</p></blockquote></li></ol><p>​        不可以。观察 <code>env.c/env_setup_vm</code> 用户空间页表页发现只有可读权限。并且实践也说明不行。</p><h3 id="7-页写入异常-内核处理"><a href="#7-页写入异常-内核处理" class="headerlink" title="7. 页写入异常 - 内核处理"></a>7. 页写入异常 - 内核处理</h3><blockquote><p>在 do_tlb_mod 函数中，你可能注意到了一个向异常处理栈复制 Trapframe运行现场的过程，请思考并回答这几个问题：</p><p>• 这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？</p><p>• 内核为什么需要将异常的现场 Trapframe 复制到用户空间？</p></blockquote><ul><li>异常重入是指一个异常在处理过程中，又触发了新的异常。此处，在处理写时复制的页写入异常时，又发生了缺页，就需要异常重入。</li><li>因为页写入异常的处理在用户态下进行。用户进程需要读取 Trapframe 的值获得哪一条指令触发了异常，并且需要 Trapframe 恢复现场。</li></ul><h3 id="8-页写入异常-内核处理1"><a href="#8-页写入异常-内核处理1" class="headerlink" title="8. 页写入异常 - 内核处理1"></a>8. 页写入异常 - 内核处理1</h3><blockquote><p>在用户态处理页写入异常，相比于在内核态处理有什么优势？ </p></blockquote><ul><li>提高系统的可靠性和稳定性。在用户态处理页写入异常时，如果出现问题，只会导致当前进程崩溃；而如果交给内核态处理，出现问题会导致整个系统崩溃，另外内核态能访问到关键数据，容易产生安全问题。</li><li>提高系统的性能。由于内核态的系统调用涉及上下文切换，会消耗一定的时间和资源。</li></ul><h3 id="9-页写入异常-内核处理2"><a href="#9-页写入异常-内核处理2" class="headerlink" title="9. 页写入异常 - 内核处理2"></a>9. 页写入异常 - 内核处理2</h3><blockquote><p>为什么需要将 syscall_set_tlb_mod_entry 的调用放置在 syscall_exofork 之前？</p></blockquote><p>我认为放在 syscall_exofork 可以，不会有影响。</p><blockquote><p>如果放置在写时复制保护机制完成之后会有怎样的效果？</p></blockquote><p><code>duppage</code> 函数会调用 <code>syscall_mem_map</code> 实现系统调用，其中调用的 <code>msyscall</code> 会将参数存入寄存器和用户栈。而用户栈可能也会被设置 <code>PTE_COW</code> 位，此时若未设置页写入异常处理函数，会无法处理页写入异常。</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">make objdump</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 epc 寻找问题发生的地方</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cause 和 badva 观察异常类型</span></span><br><span class="line">make dbg</span><br><span class="line">trace # 打开函数调用关系的输出</span><br><span class="line">c </span><br><span class="line">make dbg &gt; temp # 若输出过长,然后在 temp内操作</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户态调试类似</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="课上"><a href="#课上" class="headerlink" title="课上"></a>课上</h2><p>lab4-2 的 extra 没通过，感觉用惯了vscode，在vim上写有点慢，在vim上也不方便直接复制，下次想直接在gitlab修改，感觉会更方便，lab4-2的码量还是有的，再加上不断切换文件，速度有点慢，然后有点急，就容易读题不仔细，其中一个bug就是 sem_init 返回分配的 id，一开始没看到。另外当前进程使用某个信号量是否合法，需要判断该进程是否为创建该信号量的进程或其后代进程，由于父进程可能会丢失，直接dfs会有问题，建议并查集做。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA OO Unit3 基于规格的层次化设计</title>
      <link href="/2023/05/18/OO-unit3/"/>
      <url>/2023/05/18/OO-unit3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是2021级BUAA 面向对象课程第三单元实验——基于规格的层次化设计的博客总结。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>本单元作业需要根据 JML 规格描述实现一个社交关系模拟系统，需要阅读JML，实现高效图算法以及异常处理。下面主要从各单元图算法实现进行分析。</p><p>首先阅读 JML 发现许多方法需要通过 <code>id</code> 得到 <code>person</code> ，容易想到用 <code>HashMap</code> 进行存储。</p><h3 id="hw9-——-查询连通性和三角形关系数"><a href="#hw9-——-查询连通性和三角形关系数" class="headerlink" title="hw9 —— 查询连通性和三角形关系数"></a>hw9 —— 查询连通性和三角形关系数</h3><p>通过阅读 JML 发现在 <code>Network</code> 类的 <code>isCircle</code> 方法查询给定两点的连通性， <code>queryBlockSum</code> 方法查询连通块数量，这显然可以通过<strong>并查集</strong>实现。为了体现类的封装性，我在 <code>DisjointSet</code> 类内实现了并查集的相关操作。</p><p>三角形关系数是指三人互为熟人。如果暴力求解，时间复杂度为 $O(N^3)$ ，显然会 TLE。实际上这可以通过加边时的动态维护实现：</p><ul><li><p>在每次 <code>addRelation</code> 时，枚举除了 <code>id1</code> 和 <code>id2</code> 的所有人，若他们与二人分别有边，则关系数加1。</p></li><li><p>我们还可以进一步优化上述 O(N) 的维护算法。我们通过 <code>BitSet</code> 维护每个 <code>Person</code> 的 <code>Acquaintance</code> ，那么如果要得到二人共同的熟人只需要与一下。另外，由于 <code>Person</code> 的 <code>id</code> 仅保证在 <code>int</code> 范围内，需要给每个 <code>Person</code> 一个 <code>number</code> 属性进行离散化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPerson</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 共有多少人</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number; <span class="comment">// 本人是第几个</span></span><br><span class="line">    <span class="keyword">private</span> BitSet bitSet; <span class="comment">// 记录关系</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPerson</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">this</span>.number = tot++;</span><br><span class="line">        <span class="built_in">this</span>.bitSet = <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAcquaintance</span><span class="params">(Person person, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        bitSet.set(((MyPerson)person).getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyNetwork</span> <span class="keyword">implements</span> <span class="title class_">Network</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addRelation</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">BitSet</span> <span class="variable">bitSet</span> <span class="operator">=</span> (BitSet) ((MyPerson) getPerson(id1)).getBitSet().clone();</span><br><span class="line">        bitSet.and(((MyPerson) getPerson(id2)).getBitSet());</span><br><span class="line">        tripSum += bitSet.cardinality();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="hw10-——-有删边的连通性维护和动态维护最大值"><a href="#hw10-——-有删边的连通性维护和动态维护最大值" class="headerlink" title="hw10 —— 有删边的连通性维护和动态维护最大值"></a>hw10 —— 有删边的连通性维护和动态维护最大值</h3><p>在 <code>modifyRelation</code> 中，当修改后的 $value \leq 0$ ，两人就不再是熟人了。然而并查集并不支持删边操作。此时我认为时间复杂度合适并且实现简单的是 <strong>写时复制的并查集</strong>，当进行了删边操作时，不选择立即重建并查集，而是标记 <code>removeFlag = true</code>；在需要查询连通性时，检查 <code>removeFlag</code> ，若为 <code>true</code> ，则重建并查集。另外当 <code>removeFlag = false</code> 时，并查集失效，此时不需要在 <code>addRelation</code> 中维护并查集。</p><p>在 <code>queryBestAcquaintance</code> 方法中，需要查询该 <code>Person</code> 的所有 <code>Acquaintance</code> 中 <code>value</code> 最大的一位。这通过在新增或修改 <code>value</code> 过程中动态维护。当该 <code>person</code> 的 <code>bestAcquaintance</code> 的 <code>value</code> 减少或 <code>acquaintance</code> 删除时，遍历一遍所有 <code>Acquaintance</code> 维护。至于 <code>queryCoupleSum</code> 方法查询双方都是对方 <code>value</code> 最大的 <code>acquaintance</code> 则直接 $O(N)$ 遍历即可。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPerson</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValue</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        values.put(id, values.get(id) + value);</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span> &amp;&amp; id == bestId) &#123;</span><br><span class="line">            bestId = <span class="number">23947392</span>;</span><br><span class="line">            bestValue = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; item : values.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (item.getValue() &gt; bestValue || (item.getValue() ==</span><br><span class="line">                        bestValue &amp;&amp; item.getKey() &lt; bestId)) &#123;</span><br><span class="line">                    bestId = item.getKey();</span><br><span class="line">                    bestValue = item.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (values.get(id) &gt; bestValue || (values.get(id)</span><br><span class="line">                    == bestValue &amp;&amp; id &lt; bestId)) &#123;</span><br><span class="line">                bestId = id;</span><br><span class="line">                bestValue = values.get(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAcquaintance</span><span class="params">(Person person, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        acquaintance.put(person.getId(), person);</span><br><span class="line">        values.put(person.getId(), value);</span><br><span class="line">        bitSet.set(((MyPerson)person).getNumber());<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (bestValue &lt; value || (bestValue == value</span><br><span class="line">                &amp;&amp; bestId &gt; person.getId())) &#123;</span><br><span class="line">            bestId = person.getId();</span><br><span class="line">            bestValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAcquaintance</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        bitSet.set(((MyPerson)acquaintance.get(id)).getNumber(), <span class="literal">false</span>);<span class="comment">//</span></span><br><span class="line">        acquaintance.remove(id);</span><br><span class="line">        values.remove(id);</span><br><span class="line">        <span class="keyword">if</span> (id == bestId) &#123;</span><br><span class="line">            bestId = <span class="number">23947392</span>;</span><br><span class="line">            bestValue = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; item : values.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (item.getValue() &gt; bestValue || (item.getValue() ==</span><br><span class="line">                        bestValue &amp;&amp; item.getKey() &lt; bestId)) &#123;</span><br><span class="line">                    bestId = item.getKey();</span><br><span class="line">                    bestValue = item.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBestAcquaintance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bestId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hw11-——-查询包含某点的最小环"><a href="#hw11-——-查询包含某点的最小环" class="headerlink" title="hw11 —— 查询包含某点的最小环"></a>hw11 —— 查询包含某点的最小环</h3><p>在本次作业中 <code>message</code> 类型更多样，这些操作照着 JML 实现，一般不会有问题。</p><p>值得关注的是 <code>queryLeastMoments</code> 方法，查询包含某个点的最小环。首先想到的是 Floyed 算法，时间复杂度 $O(N^3)$ ，必然 TLE。然后想到了删边的 Dijkstra 做法，时间复杂度有点危险（确实强测点会寄一个）。然后我学习了 <a href="https://blog.csdn.net/qq_33362864/article/details/77466841"><strong>Dijkstra+并查集</strong></a> 做法：</p><ol><li><p>枚举要求经过的点 s；</p></li><li><p>用 Dijkstra 求单源最短路；</p></li><li><p>包含点s的最小环即为s到其余点的最短路的边加上一条不是最短路的边（该边有两种情况，见下图）。</p><p><img src="https://s2.loli.net/2023/05/17/5egp936xJkiUoaZ.png" alt="image-20230517171049614"></p></li></ol><p>实现细节可见代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] pre;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span>[] dist;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(MyPerson root)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">peopleLength</span> <span class="operator">=</span> root.getTot();</span><br><span class="line">       pre = <span class="keyword">new</span> <span class="title class_">int</span>[peopleLength];</span><br><span class="line">       dist = <span class="keyword">new</span> <span class="title class_">int</span>[peopleLength];</span><br><span class="line">       <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[peopleLength];</span><br><span class="line">       PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt; queue =</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(Pair::getKey));</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; peopleLength; i++) &#123;</span><br><span class="line">           dist[i] = <span class="number">999999999</span>;</span><br><span class="line">           pre[i] = i;</span><br><span class="line">           visited[i] = <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       dist[root.getNumber()] = <span class="number">0</span>;</span><br><span class="line">       Pair&lt;Integer, Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">0</span>, root.getId());</span><br><span class="line">       queue.add(pair);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           pair = queue.poll();</span><br><span class="line">           <span class="type">MyPerson</span> <span class="variable">person</span> <span class="operator">=</span> (MyPerson) getPerson(pair.getValue());</span><br><span class="line">           <span class="keyword">if</span> (visited[person.getNumber()]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">           visited[person.getNumber()] = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">for</span> (Integer item : person.getAcquaintance()) &#123;</span><br><span class="line">               <span class="type">MyPerson</span> <span class="variable">acquaintance</span> <span class="operator">=</span> (MyPerson) getPerson(item);</span><br><span class="line">               <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> person.queryValue(acquaintance);</span><br><span class="line">               <span class="keyword">if</span> (dist[acquaintance.getNumber()] &gt; dist[person.getNumber()] + value) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!person.equals(root)) &#123;</span><br><span class="line">                       pre[acquaintance.getNumber()] = person.getNumber();</span><br><span class="line">                   &#125;</span><br><span class="line">                   dist[acquaintance.getNumber()] = dist[person.getNumber()] + value;</span><br><span class="line">                   queue.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(dist[acquaintance.getNumber()], item));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (pre[x] == x) &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">       <span class="keyword">return</span> pre[x] = find(pre[x]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">queryLeastMoments</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> PersonIdNotFoundException, PathNotFoundException &#123;</span><br><span class="line">       <span class="keyword">if</span> (!contains(id)) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyPersonIdNotFoundException</span>(id); &#125;</span><br><span class="line">       <span class="comment">// 方案：以起点能到达的点做单源最短路 + 并查集</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">999999999</span>;</span><br><span class="line">       <span class="type">MyPerson</span> <span class="variable">person</span> <span class="operator">=</span> (MyPerson) getPerson(id);</span><br><span class="line">       dijkstra(person);</span><br><span class="line">       <span class="keyword">for</span> (Integer acquaintanceId : person.getAcquaintance()) &#123;</span><br><span class="line">           <span class="type">MyPerson</span> <span class="variable">acquaintance</span> <span class="operator">=</span> (MyPerson) getPerson(acquaintanceId);</span><br><span class="line">           <span class="keyword">if</span> (pre[acquaintance.getNumber()] != acquaintance.getNumber()) &#123;</span><br><span class="line">               result = Math.min(result, person.queryValue(acquaintance) +</span><br><span class="line">                       dist[acquaintance.getNumber()]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (Person p1 : people.values()) &#123;</span><br><span class="line">           <span class="type">MyPerson</span> <span class="variable">pp1</span> <span class="operator">=</span> (MyPerson) p1;</span><br><span class="line">           <span class="keyword">if</span> (pp1.equals(person)) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">           <span class="keyword">for</span> (Integer item : pp1.getAcquaintance()) &#123;</span><br><span class="line">               <span class="type">MyPerson</span> <span class="variable">pp2</span> <span class="operator">=</span> (MyPerson) getPerson(item);</span><br><span class="line">               <span class="keyword">if</span> (!pp2.equals(person) &amp;&amp; find(pp1.getNumber()) != find(pp2.getNumber())) &#123;</span><br><span class="line">                   result = Math.min(result, dist[pp1.getNumber()] +</span><br><span class="line">                           dist[pp2.getNumber()] + pp1.queryValue(pp2));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (result == <span class="number">999999999</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyPathNotFoundException</span>(id); &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p><strong>白箱测试</strong>是指根据程序内部逻辑测试程序，检查程序中的每条通路是否按照预定要求正确工作（即穷举路径），要求测试者了解程序结构和处理过程。</p><ol><li>语句覆盖（Statement Coverage）：确保每个代码语句都至少执行一次。</li><li>分支覆盖（Branch Coverage）：确保每个分支（如if语句中的条件判断）的两个可能结果（真和假）都至少执行一次。</li><li>条件覆盖（Condition Coverage）：确保每个条件的所有可能取值都被测试到。</li><li>路径覆盖（Path Coverage）：确保每个可能的路径都被覆盖到。</li><li>边界值测试（Boundary Value Testing）：测试边界值和特殊情况，例如最小和最大输入值、边界条件和异常情况。</li></ol><p><strong>黑箱测试</strong> 是指根据功能需求测试程序是否按照预期工作，基于系统的需求规格和功能规范来设计测试用例，并通过输入不同的数据和条件，观察系统的输出是否符合预期（即穷举输入），而不涉及程序的内部结构和内容特性。</p><ol><li>等价类划分（Equivalence Partitioning）：将输入数据划分为等价类，每个等价类中的数据被认为具有相同的测试行为，从每个等价类中选择代表性的测试数据。</li><li>边界值分析（Boundary Value Analysis）：测试输入数据的边界情况，例如最小值、最大值以及接近边界的值，因为边界处往往容易出现错误。</li><li>错误推测（Error Guessing）：基于测试人员的经验和直觉，猜测可能存在的错误，并设计测试用例以验证这些猜测。</li><li>随机测试（Random Testing）：使用随机生成的测试数据进行测试，以发现潜在的错误和异常情况。</li><li>用户场景测试（User Scenario Testing）：基于用户的实际使用场景和预期行为，设计测试用例来模拟用户的操作和交互。</li></ol><p><strong>单元测试</strong> 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。它的目的是在开发过程中尽早发现代码中的缺陷，并确保每个功能模块都能够独立地正常运行。</p><ol><li><u>高度自动化</u>：单元测试通常是自动化的，开发人员编写测试代码，并使用测试框架执行测试。这样可以快速、方便地运行测试，并重复执行以确保稳定性。</li><li>针对最小单元：单元测试的重点是测试代码的最小可测试单元，通常是一个函数或方法。通过隔离单个功能模块，可以更容易地定位和修复问题。</li><li>独立性：每个单元测试应该是相互独立的，不依赖于其他单元测试的运行结果。这种独立性有助于更好地定位和排查问题，也使得测试更加可靠和可重复。</li><li>快速执行：由于单元测试关注最小单元，测试执行速度通常很快。这样可以迅速获得反馈，使开发人员能够快速修复问题。</li><li>提高代码质量：通过编写单元测试，开发人员可以更好地理解功能模块的需求和预期行为。这有助于提高代码质量、降低bug出现的概率，并促使开发人员编写更可靠、健壮的代码。</li></ol><p><strong>功能测试</strong> 是测试软件功能是否符合需求，通常采用黑箱测试方法。</p><p><strong>集成测试</strong> 是软件测试的一种方法，用于验证不同组件、模块或子系统之间的集成是否正确、协同合作，并能够产生预期的结果。它旨在检测和解决在组件集成过程中可能出现的问题。在集成测试中，被测试的软件系统已经通过单元测试对各个组件进行了测试，并且这些组件已经通过了单元测试阶段。集成测试的目标是验证组件之间的接口、数据传递和交互是否正常，以及确保整个系统在集成后能够正确运行。</p><p><strong>压力测试</strong> 是软件测试的一种方法，用于评估系统在超出正常工作负载条件下的性能和稳定性。它通过模拟系统面临的高负载、大数据量或高并发等情况，检查系统在这些极端情况下的表现和响应。压力测试的主要目标是找出系统的瓶颈、性能问题和资源耗尽情况，并评估系统在负载增加时是否能够满足性能要求。这种测试方法可以揭示系统的弱点、性能限制和潜在的故障，为系统的优化和调整提供指导。</p><p><strong>回归测试</strong> 软件测试的一种方法，用于确认在进行软件修改、修复或增加新功能后，原有功能是否仍然正常工作，以及新的修改是否引入了新的错误或问题。当对软件进行修改时，无论是修复缺陷、添加新功能还是进行系统配置变更，都存在可能引入新的错误或导致原有功能出现问题的风险。回归测试的目的是在进行修改后，重新运行既有的测试用例，以验证软件系统在修改后的版本中是否仍然具有预期的行为。</p><h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><p>由于本单元作业的实现并不复杂，白箱测试我通过人工逻辑分析与检查替代，在完成代码编写后，先浏览一遍，和 JML 比对，检查是否有疏忽，这能解决 60% 的 bug。</p><p>然后编写测试用例，主要通过生成随机性和大数据量的测试用例来完成黑箱测试，缺点是这样仍然难以保证覆盖性。</p><h2 id="规格与实现分离"><a href="#规格与实现分离" class="headerlink" title="规格与实现分离"></a>规格与实现分离</h2><p>规格与实现分离是指将规格说明与具体实现分开，以实现更好的灵活性、可维护性和可扩展性。通过本单元作业，我认识到了规格与实现分离的一些好处：</p><ul><li>灵活性和可维护性。如果需要对系统进行功能增加、修改或优化，只需更改实现部分而不影响规格，从而降低了修改带来的风险，并提高了系统的灵活性和可维护性。通过阅读 JML 规格，可以很清晰地发现哪些实现需要修改，提高了效率。</li><li>可测试性。根据规格编写测试用例，可以验证实现是否符合规格要求，从而提高软件的质量和可靠性。本单元作业同学们的架构比较相似，降低了互测阅读源码寻找bug的复杂性。</li></ul><p>在 hw11 中，我在做 Dijkstra 使用 <code>int dist[people.length]</code> （得益于离散化操作，不需要使用 HashMap）, 但是 run 类调用 <code>addPerson</code> 方法时，即使该 <code>person</code> 非法，我也赋予了他 <code>myID</code> ，导致 <code>people.size != tot</code>。</p><p>在我的实现中，规格与实现分离的很好的一个体现就是在求连通性时新增了 <code>DisjointSet</code> 类实现并查集相关操作，也让后续维护更清晰。</p><h2 id="OK测试方法"><a href="#OK测试方法" class="headerlink" title="OK测试方法"></a>OK测试方法</h2><p>OK测试对于检验代码实现与规格的一致性的作用：</p><ul><li>通过对比代码实现与规格要求，可以发现代码中的错误和缺陷。</li><li>确保代码实现了规格中定义的所有功能，并且没有遗漏或错误地实现了某些功能。</li></ul><p>不过，我在本单元作业中对其感触不深，可能对我最大的用处就是在写OKTest时回忆检测的方法对象是否完全实现。因为理论上来说，OK测试应该调用我实现的方法判断数据处理前后是否满足规格，但显然这样课程组很难测试，于是课程组采用传入输入输出数据来判断，于是我的OKTest实现就变成了这样,我感觉和OK测试的初衷没啥关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteColdEmojiOKTest</span><span class="params">(<span class="type">int</span> limit, ArrayList&lt;HashMap&lt;Integer, Integer&gt;&gt; beforeData,</span></span><br><span class="line"><span class="params">                                     ArrayList&lt;HashMap&lt;Integer, Integer&gt;&gt; afterData, <span class="type">int</span> result)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; beforeEmojis;</span><br><span class="line">        beforeEmojis = beforeData.get(<span class="number">0</span>);</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; beforeMessages;</span><br><span class="line">        beforeMessages = beforeData.get(<span class="number">1</span>);</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; afterEmojis;</span><br><span class="line">        afterEmojis = afterData.get(<span class="number">0</span>);</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; afterMessages;</span><br><span class="line">        afterMessages = afterData.get(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; item : beforeEmojis.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.getValue() &gt;= limit) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span> (!afterEmojis.containsKey(item.getKey())) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; item : afterEmojis.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beforeEmojis.containsKey(item.getKey())) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (beforeEmojis.get(item.getKey()) != item.getValue()) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (afterEmojis.size() != num) &#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; item : beforeMessages.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.getValue() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (afterEmojis.containsKey(item.getValue())) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    <span class="keyword">if</span> (!afterMessages.containsKey(item.getKey())) &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!Objects.equals(afterMessages.get(</span><br><span class="line">                            item.getKey()), item.getValue())) &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!afterMessages.containsKey(item.getKey())) &#123; <span class="keyword">return</span> <span class="number">6</span>; &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (afterMessages.get(item.getKey()) != <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="number">6</span>; &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (afterMessages.size() != num) &#123; <span class="keyword">return</span> <span class="number">7</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != afterEmojis.size()) &#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><p>本单元我觉得重点不在于代码的实现，而是<strong>基于规格的层次化设计</strong>，掌握了数据、方法、类的规格及其设计方法和基于规格的测试方法。编写 JML 规格可以提高设计的正确性和可迭代性，我认为这钟设计方式在未来大型项目团队合作中非常需要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Object Oriented </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab3</title>
      <link href="/2023/04/18/Lab3/"/>
      <url>/2023/04/18/Lab3/</url>
      
        <content type="html"><![CDATA[<p><strong>keywords：进程，异常</strong></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。从概念上说，每个进程拥有它自己的虚拟CPU，实际上真正的CPU在各个进程之间来回切换。</p><blockquote><p>由于没有实现线程，本实验中进程既是基本的分配单元，也是基本的执行单元。</p></blockquote><h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><h4 id="进程的三种状态"><a href="#进程的三种状态" class="headerlink" title="进程的三种状态"></a>进程的三种状态</h4><ul><li>运行态（该时刻进程实际占用CPU）</li><li>就绪态（可运行，但因为其他进程正在运行而暂时停止）</li><li>阻塞态（除非某种外部事件发生，否则进程不能运行）</li></ul><p><img src="https://s2.loli.net/2023/04/10/iMhs6YndcIKrlNS.png" alt="image-20230410115339401"></p><p>进程控制块 (PCB) 是系统专门设置用来管理进程的数据结构，它可以记录进程的外部特征，描述进程的变化过程。</p><blockquote><p>在 MOS 中，PCB 由一个 Env 结构体实现。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>  <span class="comment">// Saved registers</span></span><br><span class="line"><span class="comment">// env_tf: Trapframe 在include/trap.h中定义，在发生进程调度或当陷入内核时，会将当时的进程上下文环境(CP0)保存在env_tf变量中</span></span><br><span class="line">LIST_ENTRY(Env) env_link; <span class="comment">// Free list</span></span><br><span class="line"><span class="comment">// env_link：使用其构造空闲进程链表env_free_list</span></span><br><span class="line">u_int env_id;  <span class="comment">// Unique environment identifier</span></span><br><span class="line"><span class="comment">// env_id：进程独一无二的标识符</span></span><br><span class="line">u_int env_asid;  <span class="comment">// ASID</span></span><br><span class="line">u_int env_parent_id;  <span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line"><span class="comment">// env_parent_id：进程是可以被其它进程创建的，创建本进程的进程称为父进程。此变量记录父进程的进程id。进程树</span></span><br><span class="line">u_int env_status;  <span class="comment">// Status of the environment</span></span><br><span class="line"><span class="comment">// env_status：ENV_FREE(进程空闲链表)，ENV_NOT_RUNNABLE(阻塞状态)，ENV_RUNNABLE(执行状态或就绪状态)</span></span><br><span class="line">Pde *env_pgdir;  <span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line"><span class="comment">// env_pgdir：该进程页目录的内核虚拟地址</span></span><br><span class="line">TAILQ_ENTRY(Env) env_sched_link;</span><br><span class="line"><span class="comment">// env_sched_link：构造调度队列env_sched_list</span></span><br><span class="line">u_int env_pri;</span><br><span class="line"><span class="comment">// env_pri：保存了该进程的优先级</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>envs</code> 数组用于存放进程控制块的物理内存。</p><p><code>envs_free_list</code> 按照链表形式保存空闲的进程控制块。</p><p><code>env_sched_list</code> 按照双端队列(TAILQ)形式保存调度队列。</p><p>==在 exercise 3.1 中，envs的大小是 NENV .==</p><h3 id="段地址映射"><a href="#段地址映射" class="headerlink" title="段地址映射"></a>段地址映射</h3><p><code>base_pgdir</code> 模板页表：</p><p><code>void map_segment(Pde *pgdir, u_long pa, u_long va, u_long size,u_int perm)</code>段地址映射函数：功能是在一级页表基地址 pgdir 对应的两级页表结构中做段地址映射，将虚拟地址段 [va,va+size) 映射到物理地址段 [pa,pa+size)，因为是按页映射，要求 size 必须是页面大小的整数倍。同时为相关页表项的权限为设置为 perm。</p><h3 id="进程的标识"><a href="#进程的标识" class="headerlink" title="进程的标识"></a>进程的标识</h3><p><strong>ASID</strong>：ASID 是 Address Space ID 的缩写，它是一种处理器（CPU）的硬件机制，用于区分和隔离不同的进程或线程之间的虚拟地址空间。每个进程或线程都有一个<strong>唯一的 ASID</strong>，用于标识其虚拟地址空间。当处理器执行一个新的进程或线程时，它会切换 ASID，以确保当前运行的进程或线程的虚拟地址空间与先前运行的进程或线程相隔离，这有助于保护系统的安全性和稳定性。</p><p><code>struct Env</code> 进程控制块中的 <code>env_id</code> 域，是每个进程独一无二的标识符，需要在进程创建的时候就被赋予。</p><p><code>mkenvid</code> 函数：生成一个新的进程标识符。</p><p><code>asid_alloc</code>：ASID 部分只占据了 6-11 共 6 个 bit。实验采用了<strong>位图法</strong>管理 64 个可用的 ASID，如果ASID 耗尽时仍要创建进程，内核会发生崩溃（panic）。</p><h3 id="设置进程控制块"><a href="#设置进程控制块" class="headerlink" title="设置进程控制块"></a>设置进程控制块</h3><p><strong>4种主要事件会导致进程的创建</strong>：</p><ol><li>系统初始化。</li><li>正在运行的程序执行了创建进程的系统调用。</li><li>用户请求创建一个新进程。</li><li>一个批处理作业的初始化。</li></ol><p><strong>进程创建流程</strong>：</p><ol><li><p>申请一个空闲的 PCB（也就是 Env 结构体），<strong>从 env_free_list 中索取一个空闲PCB 块</strong>，这时候的 PCB 就像张白纸一样。</p></li><li><p>“纯手工打造”打造一个进程。在这种创建方式下，由于没有模板进程，所以进程拥有的所有信息都是手工设置。而进程的信息又都存放于进程控制块中，所以需要手工<strong>初始化进程控制块</strong>。</p></li><li><p>进程光有 PCB 的信息还没法跑起来，每个进程都有独立的地址空间。所以，要<strong>为新进程初始化页目录</strong>。</p></li><li>此时 PCB 已经被填写了很多东西，不再是一张白纸，<strong>把它从空闲链表里摘出</strong>，就可以使用。</li></ol><p><code>env_setup_vm</code> ：初始化新进程的地址空间。（我们要暴露 UTOP 往上到 UVPT 之间所有进程共享的只读空间，也就是把这部分内存对应的内核页表 base_pgdir 拷贝到进程页表中。从 UVPT 往上到 ULIM 之间则是进程自己的页表。）</p><h3 id="加载二进制镜像"><a href="#加载二进制镜像" class="headerlink" title="加载二进制镜像"></a>加载二进制镜像</h3><p>在进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他线程是不可见的。每个进程有自己独立的地址空间，当进程创建后，需要把程序（本节中的程序指可执行文件）加载到新进程的地址空间中。在本实验中，只需要将 ELF 文件中所有需要加载的程序段 （program segment）加载到对应的虚拟地址上即可。</p><p>本部分涉及的函数主要为 <code>load_icode_mapper</code> 和 <code>load_icode</code> :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load_icode 函数负责加载可执行文件 binary 到进程 e 的内存中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line"><span class="comment">// ① elf_from：解析 ELF 文件头的部分</span></span><br><span class="line"><span class="type">const</span> Elf32_Ehdr *ehdr = elf_from(binary, size); </span><br><span class="line"><span class="keyword">if</span> (!ehdr) &#123;</span><br><span class="line">panic(<span class="string">&quot;bad elf at %x&quot;</span>, binary);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">size_t</span> ph_off;</span><br><span class="line">ELF_FOREACH_PHDR_OFF (ph_off, ehdr) &#123;</span><br><span class="line">Elf32_Phdr *ph = (Elf32_Phdr *)(binary + ph_off);</span><br><span class="line"><span class="keyword">if</span> (ph-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">            <span class="comment">// elf_load_seg: 将 ELF 文件的一个 segment 加载到进程的地址空间中</span></span><br><span class="line">            <span class="comment">// ph: 每个segment的段头; binary+ph-&gt;p_offset: 其数据在内存中的起始位置</span></span><br><span class="line">panic_on(elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">e-&gt;env_tf.cp0_epc = ehdr-&gt;e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>elf_load_seg(ph, bin, map_page, data)</code> ：每当 <code>elf_load_seg</code> 函数解析到一个需要加载到内存中的页面，会将有关的信息作为参数传递给回调函数，并由它完成单个页面的加载过程，而这里 <code>load_icode_mapper</code> 就是 <code>map_page</code> 的具体实现。</p><p><code>elf_load_seg</code> 函数会从 <code>ph</code> 中获取 <code>va</code>（该段需要被加载到的虚地址）、<code>sgsize</code>（该段在内存中的大小）、<code>bin_size</code>（该段在文件中的大小）和 <code>perm</code>（该段被加载时的页面权限），并根据这些信息完成以下两个步骤：</p><ol><li>加载该段的所有数据（<code>bin</code>）中的所有内容到内存（<code>va</code>）。</li><li>如果该段在文件中的内容的大小达不到为填入这段内容新分配的页面大小，即分配了新的页面但没能填满（如 <code>.bss</code> 区域），那么余下的部分用 0 来填充。</li></ol><p><code>elf_load_seg</code> 会正确处理虚拟地址 <code>va</code>、该段占据的内存长度 <code>sg_size</code> 以及需要拷贝的数据长度 <code>bin_size</code>的页面偏移，对于每个需要加载的页面，用<strong>对齐后</strong>的地址 <code>va</code> 以及该页的其他信息调用回调函数 <code>map_page</code>，由回调函数完成单页的加载。</p><p><code>load_icode_mapper</code>：单个页面的加载。分配所需的物理页面，并在页表中建立映射。若 src 非空，你还需要将该处的 ELF 数据拷贝到物理页面中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> =</span> (<span class="keyword">struct</span> Env *)data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 1: Allocate a page with &#x27;page_alloc&#x27;. */</span></span><br><span class="line"><span class="keyword">if</span> (page_alloc(&amp;p) != <span class="number">0</span>) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Step 2: If &#x27;src&#x27; is not NULL, copy the &#x27;len&#x27; bytes started at &#x27;src&#x27; into &#x27;offset&#x27; at this page. */</span></span><br><span class="line"><span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)(page2kva(p) + offset), src, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: Insert &#x27;p&#x27; into &#x27;env-&gt;env_pgdir&#x27; at &#x27;va&#x27; with &#x27;perm&#x27;. */</span></span><br><span class="line"><span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, p, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>本部分的“创建进程”是指在操作系统内核初始化时直接创建进程，所需做的是分配一个新的 Env 结构体，设置进程控制块，并将程序载入到该进程的地址空间，将新创建的进程放入 env_sched_list。</p><h3 id="进程运行与切换"><a href="#进程运行与切换" class="headerlink" title="进程运行与切换"></a>进程运行与切换</h3><p>运行一个新进程往往意味着进程切换。进程切换时需要保存进程的上下文信息，包括通用寄存器、HI、LO 和 CP0 中的 SR，EPC，Cause 和 BadVAddr 寄存器。</p><p>env_run 的执行流程：</p><ol><li><p>保存当前进程的上下文信息。</p></li><li><p>切换 curenv 为即将运行的进程。</p></li><li><p>设置全局变量 cur_pgdir 为当前进程页目录地址，在 TLB 重填时将用到该全局变量。</p></li><li><p>调用 env_pop_tf 函数，恢复现场、异常返回。</p></li></ol><h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><p>CO中我们已经接触过 CP0 协处理器。</p><p><img src="https://s2.loli.net/2023/04/11/YjaxXepHQ19cGPN.png" alt="image-20230411171744895"></p><p>MIPS CPU 处理一个异常时大致要完成四项工作：</p><ol><li>设置 EPC 指向从异常返回的地址。</li><li>设置 SR 位，强制 CPU 进入内核态（行使更高级的特权）并禁止中断。</li><li>设置 Cause 寄存器，用于记录异常发生的原因。</li><li>CPU 开始从异常入口位置取指，此后一切交给软件处理。</li></ol><h3 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h3><p>时间片轮转调度是一种进程调度算法，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则该进程将挂起，切换到另一个进程运行。</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>调用 schedule 函数时，当前正在运行的进程被存储在全局变量 curenv 中（在第一个进程被调度前为 NULL），其剩余的时间片数量被存储在静态变量 count 中。我们考虑是否需要从调度链表头部取出一个新的进程来调度，有这几种应进行进程切换的情况：</p><ul><li><p>尚未调度过任何进程。</p></li><li><p>当前进程已经用完了时间片。</p></li><li>当前进程不再就绪（如被阻塞或退出）。</li><li>yield 参数指定必须发生切换。</li></ul><p>在发生切换的情况下，我们还需要判断当前进程是否仍然就绪，如果是则将其移动到调度链表的尾部。之后，我们从调度链表头部取出一个新的进程来调度，将时间片数量设置为其优先级。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h5 id="1-请结合-MOS-中的页目录自映射应用解释代码中-e-gt-env-pgdir-PDX-UVPT-PADDR-e-gt-env-pgdir-PTE-V-的含义。"><a href="#1-请结合-MOS-中的页目录自映射应用解释代码中-e-gt-env-pgdir-PDX-UVPT-PADDR-e-gt-env-pgdir-PTE-V-的含义。" class="headerlink" title="1. 请结合 MOS 中的页目录自映射应用解释代码中 e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V 的含义。"></a>1. 请结合 MOS 中的页目录自映射应用解释代码中 e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V 的含义。</h5><p><code>e-&gt;env_pgdir</code> 表示一个进程的页目录表，<code>PDX(UVPT)</code> 表示将自身的页目录表映射到虚拟地址空间中的地址，<code>PADDR(e-&gt;env_pgdir)</code> 获取 <code>e-&gt;env_pgdir</code> 所在的物理页框的地址，<code>PTE_V</code> 表示该页表项是有效的。这行代码是将进程 <code>e</code> 的页目录表自映射到虚拟地址空间的 <code>UVPT</code> 上，以便进程可以通过访问 <code>UVPT</code> 来访问自己的页目录表。</p><h5 id="2-elf-load-seg-以函数指针的形式，接受外部自定义的回调函数-map-page。请你找到与之相关的-data-这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？"><a href="#2-elf-load-seg-以函数指针的形式，接受外部自定义的回调函数-map-page。请你找到与之相关的-data-这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？" class="headerlink" title="2. elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？"></a>2. elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</h5><p><code>int elf_load_seg(Elf32_Phdr ph, const void bin, elf_mapper_t map_page, void data);</code></p><p>在 <code>load_icode</code> 函数中调用 <code>elf_load_seg</code> 时data 传入的是进程控制块 <code>e</code>。观察 <code>load_icode_mapper</code> 发现 创建的新页面插入时需要传入该页面所属进程的页目录基地址和 asid。显然不可以没有这个参数，因为每个进程由独立的地址空间，需要该参数区分页面所属的进程。</p><h5 id="3-结合-elf-load-seg-的参数和实现，考虑该函数需要处理哪些页面加载的情况。"><a href="#3-结合-elf-load-seg-的参数和实现，考虑该函数需要处理哪些页面加载的情况。" class="headerlink" title="3. 结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。"></a>3. 结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</h5><p><code>elf_load_seg</code> 函数会从 <code>ph</code> 中获取 <code>va</code>（该段需要被加载到的虚地址）、<code>sgsize</code>（该段在内存中的大小）、<code>bin_size</code>（该段在文件中的大小）和 <code>perm</code>（该段被加载时的页面权限），并根据这些信息完成以下两个步骤：</p><ol><li>加载该段的所有数据（<code>bin</code>）中的所有内容到内存（<code>va</code>）。</li><li>如果该段在文件中的内容的大小达不到为填入这段内容新分配的页面大小，即分配了新的页面但没能填满（如 <code>.bss</code> 区域），那么余下的部分用 0 来填充。</li></ol><p><code>elf_load_seg</code> 会正确处理虚拟地址 <code>va</code>、该段占据的内存长度 <code>sg_size</code> 以及需要拷贝的数据长度 <code>bin_size</code>的页面偏移，对于每个需要加载的页面，用<strong>对齐后</strong>的地址 <code>va</code> 以及该页的其他信息调用回调函数 <code>map_page</code>，由回调函数完成单页的加载。</p><p><code>u_long va</code>: 该段需要被加载到的虚拟地址。</p><p><code>size_t bin_size</code>：该段在文件中的大小。</p><p><code>size_t sgsize</code>：该段在内存中的大小。</p><p><code>u_int perm</code>：该段被加载时的页面权限</p><p><code>elf_mapper_t map_page</code> ： 回调函数</p><p><code>void *data</code>：回调函数所需的参数</p><p><img src="https://s2.loli.net/2023/04/11/v4qWTJd2CuHZ7xY.png" alt="image-20230411170017902"></p><p>需要处理的页面加载情况：</p><ol><li>虚拟地址 <code>va</code> 未页对齐，填写offset - min(bin_size, BY2PG - offset) 部分。</li><li>bin中已页对齐的部分。</li><li>若 bin_size &lt; sgsize，分配一些用0补充的页面。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">elf_load_seg</span><span class="params">(Elf32_Phdr *ph, <span class="type">const</span> <span class="type">void</span> *bin, <span class="type">elf_mapper_t</span> map_page, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">u_long va = ph-&gt;p_vaddr;</span><br><span class="line"><span class="type">size_t</span> bin_size = ph-&gt;p_filesz;</span><br><span class="line"><span class="type">size_t</span> sgsize = ph-&gt;p_memsz;</span><br><span class="line">u_int perm = PTE_V;</span><br><span class="line"><span class="keyword">if</span> (ph-&gt;p_flags &amp; PF_W) &#123;</span><br><span class="line">perm |= PTE_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line">u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line"><span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))) !=</span><br><span class="line">    <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 1: load all content of bin into memory. */</span></span><br><span class="line"><span class="keyword">for</span> (i = offset ? MIN(bin_size, BY2PG - offset) : <span class="number">0</span>; i &lt; bin_size; i += BY2PG) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, bin + i, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 2: alloc pages to reach `sgsize` when `bin_size` &lt; `sgsize`. */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">i += BY2PG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-思考上面这一段话，并根据自己在-Lab2-中的理解，回答：你认为这里的-env-tf-cp0-epc-存储的是物理地址还是虚拟地址"><a href="#4-思考上面这一段话，并根据自己在-Lab2-中的理解，回答：你认为这里的-env-tf-cp0-epc-存储的是物理地址还是虚拟地址" class="headerlink" title="4. 思考上面这一段话，并根据自己在 Lab2 中的理解，回答：你认为这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址?"></a>4. 思考上面这一段话，并根据自己在 <strong>Lab2</strong> 中的理解，回答：你认为这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址?</h5><p>虚拟地址</p><p>在计算机中，CPU处理之灵使用的是虚拟地址，虚拟地址通过地址翻译机制转换为物理地址，然后访问内存。但是，有些情况下需要直接使用物理地址进行访问：</p><ol><li>内核态下：当操作系统内核运行在特权级别最高的 CPU 模式下时，它可以访问整个物理地址空间。此时，内核可以直接使用物理地址访问系统中的任何内存区域，包括用户态下不可访问的区域。</li><li>设备驱动程序：设备驱动程序通常运行在内核态下，用于控制和管理计算机系统中的外部设备。在这种情况下，驱动程序需要直接使用物理地址来访问设备控制寄存器、DMA 缓冲区等硬件资源。</li><li>页表初始化：在计算机系统启动时，操作系统需要初始化页表，以便将虚拟地址映射到正确的物理地址。在这种情况下，操作系统需要直接访问物理地址以初始化页表。</li></ol><h5 id="5-Thinking-3-5-试找出上述-5-个异常处理函数的具体实现位置。"><a href="#5-Thinking-3-5-试找出上述-5-个异常处理函数的具体实现位置。" class="headerlink" title="5. Thinking 3.5 试找出上述 5 个异常处理函数的具体实现位置。"></a>5. <strong>Thinking 3.5</strong> 试找出上述 5 个异常处理函数的具体实现位置。</h5><p><strong>0</strong> 号异常 的处理函数为 handle_int，表示中断，由时钟中断、控制台中断等中断造成。</p><p><strong>1</strong> 号异常 的处理函数为 handle_mod，表示存储异常，进行存储操作时该页被标记为只读</p><p><strong>2</strong> 号异常 的处理函数为 handle_tlb，表示 TLB load 异常</p><p><strong>3</strong> 号异常 的处理函数为 handle_tlb，表示 TLB store 异常</p><p><strong>8</strong> 号异常 的处理函数为 handle_sys，表示系统调用，用户进程通过执行 syscall 指令陷入内核</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// kern/genex.S</span><br><span class="line">NESTED(handle_int, TF_SIZE, zero)</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2</span><br><span class="line">andi    t1, t0, STATUS_IM4</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">// TODO: handle other irqs</span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">li      a0, 0</span><br><span class="line">j       schedule</span><br><span class="line">END(handle_int)</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER tlb do_tlb_refill</span><br><span class="line"></span><br><span class="line">#if !defined(LAB) || LAB &gt;= 4</span><br><span class="line">BUILD_HANDLER mod do_tlb_mod</span><br><span class="line">BUILD_HANDLER sys do_syscall</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER reserved do_reserved</span><br></pre></td></tr></table></figure><h5 id="6-阅读-init-c、kclock-S、env-asm-S-和-genex-S-这几个文件，并尝试说出-enable-irq-和-timer-irq-中每行汇编代码的作用。"><a href="#6-阅读-init-c、kclock-S、env-asm-S-和-genex-S-这几个文件，并尝试说出-enable-irq-和-timer-irq-中每行汇编代码的作用。" class="headerlink" title="6. 阅读 init.c、kclock.S、env_asm.S 和 genex.S 这几个文件，并尝试说出 enable_irq 和 timer_irq 中每行汇编代码的作用。"></a>6. 阅读 init.c、kclock.S、env_asm.S 和 genex.S 这几个文件，并尝试说出 enable_irq 和 timer_irq 中每行汇编代码的作用。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 开启中断</span><br><span class="line">LEAF(enable_irq)</span><br><span class="line">li      t0, (STATUS_CU0 | STATUS_IM4 | STATUS_IEc) </span><br><span class="line"># 将协处理器0(COP0)交给当前进程使用 &amp;&amp; 4号中断可响应（即计时器中断） &amp;&amp; 启用CP0接收中断</span><br><span class="line">mtc0    t0, CP0_STATUS</span><br><span class="line"># 修改 SR 寄存器</span><br><span class="line">jr      ra</span><br><span class="line"># 返回</span><br><span class="line">END(enable_irq)</span><br><span class="line"></span><br><span class="line"># 中断服务函数</span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_INTERRUPT_ACK)</span><br><span class="line"># 将零值存入一个地址中，该地址表示时钟中断确认寄存器，表示清除时钟中断</span><br><span class="line">li      a0, 0</span><br><span class="line"># 将 a0 寄存器的值清零，以便后续操作使用</span><br><span class="line">j       schedule</span><br><span class="line"># 跳转到调度函数</span><br></pre></td></tr></table></figure><h5 id="7-阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。"><a href="#7-阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。" class="headerlink" title="7. 阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。"></a>7. 阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</h5><p>每隔一个时间片，调用 schedule 函数，如果 count = 0，说明当前进程时间片已用完，切换进程。</p><h2 id="课上实验"><a href="#课上实验" class="headerlink" title="课上实验"></a>课上实验</h2><p>exam 是实现多用户调度，花了半小时写出来，不需要debug，总体来说没啥问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> user_time[<span class="number">5</span>]; <span class="comment">// 创建一个用户累计运行时间片数数组</span></span><br><span class="line"><span class="type">int</span> tmp[<span class="number">5</span>], i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_tmp</span>;</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">tmp[i] = <span class="number">0</span>;</span><br><span class="line">TAILQ_FOREACH(env_tmp, &amp;env_sched_list, env_sched_link) &#123;</span><br><span class="line">tmp[env_tmp-&gt;env_user] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span> || yield || e == <span class="literal">NULL</span> || e-&gt;env_status != ENV_RUNNABLE) &#123;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">user_time[e-&gt;env_user] += e-&gt;env_pri;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list)) &#123;</span><br><span class="line">panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> usr = <span class="number">-1</span>, t = <span class="number">999999999</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp[i] &amp;&amp; user_time[i] &lt; t) &#123;</span><br><span class="line">usr = i;</span><br><span class="line">t = user_time[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">TAILQ_FOREACH(env_tmp, &amp;env_sched_list, env_sched_link) &#123;</span><br><span class="line"><span class="keyword">if</span> (env_tmp-&gt;env_user == usr) &#123;</span><br><span class="line">e = env_tmp;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">count = e-&gt;env_pri;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">count --;</span><br><span class="line">env_run(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>extra 卡住的点主要是没有去看 va2pa 函数的实现，即调用 va2pa 时需要 + 偏移。课上提供了一种把 kuseg 转换为 kseg0 然后直接访存的操作。之所以对虚拟地址赋值就是对物理地址赋值是因为 gxemul 进行了转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_ov</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">curenv-&gt;env_ov_cnt++;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> epc = tf-&gt;cp0_epc;</span><br><span class="line">u_long value = *(u_long *)epc;</span><br><span class="line">Pte *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span> =</span> page_lookup(curenv-&gt;env_pgdir, epc, &amp;pte);</span><br><span class="line">u_long kva = KADDR(PTE_ADDR(*pte)) + (epc &amp; <span class="number">0xfff</span>);</span><br><span class="line"><span class="keyword">if</span> ((value&amp;<span class="number">0x3f</span>) == <span class="number">32</span>) &#123;</span><br><span class="line">*(u_long *)kva = (value &amp; ~<span class="number">0x3f</span>) | <span class="number">0x21</span>;</span><br><span class="line">printk(<span class="string">&quot;add ov handled\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((value&amp;<span class="number">0x3f</span>) == <span class="number">0x22</span>) &#123;</span><br><span class="line">*(u_long *)kva = (value &amp; ~<span class="number">0x3f</span>) | <span class="number">0x23</span>;</span><br><span class="line">printk(<span class="string">&quot;sub ov handled\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((value&gt;&gt;<span class="number">26</span>) == <span class="number">0x8</span>) &#123;</span><br><span class="line"><span class="type">int</span> s = (value &gt;&gt; <span class="number">21</span>) &amp; <span class="number">0x1f</span>;</span><br><span class="line"><span class="type">int</span> t = (value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x1f</span>;</span><br><span class="line">u_int imm = (value &amp; <span class="number">0xffff</span>);</span><br><span class="line">tf-&gt;regs[t] = (tf-&gt;regs[s]&gt;&gt;<span class="number">1</span>) + (imm&gt;&gt;<span class="number">1</span>);</span><br><span class="line">tf-&gt;cp0_epc +=<span class="number">4</span>;</span><br><span class="line">printk(<span class="string">&quot;addi ov handled\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OS实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA OO Unit2 多线程实时电梯系统</title>
      <link href="/2023/04/17/OO-unit2/"/>
      <url>/2023/04/17/OO-unit2/</url>
      
        <content type="html"><![CDATA[<h2 id="基于Pipeline模式的架构设计"><a href="#基于Pipeline模式的架构设计" class="headerlink" title="基于Pipeline模式的架构设计"></a>基于Pipeline模式的架构设计</h2><p>Pipeline 模式也称为流水线模式。将一个任务处理分解为若干个处理阶段，其中每个处理阶段的输出作为下一个处理阶段的输入，并且各个处理阶段都有相应的工作者线程去执行相应的计算。</p><h3 id="hw5-需求分析"><a href="#hw5-需求分析" class="headerlink" title="hw5 需求分析"></a>hw5 需求分析</h3><blockquote><p>模拟多线程实时电梯系统。系统从标准输入中输入请求信息，程序进行接收和处理，模拟电梯运行，将必要的运行信息通过输出接口进行输出。 具体而言，本次作业电梯系统具有的功能为：上下行，开关门，以及模拟乘客的进出。</p><p>输入输出定义：</p><p>​    输入：[时间戳]ID-FROM-x-TO-y：乘客从x层到y层</p><p>​    输出：[时间戳]电梯ID-动作</p><p>​        电梯动作：开门、关门、到达楼层</p><p>​        乘客动作：进入、离开电梯</p><p>电梯：</p><p>​    电梯各项参数静态不可变（运行速度、开关门耗时、限乘人数、楼层数、初始位置）</p><p>​    6部电梯</p></blockquote><ol><li>线程的设计。系统获取请求，由调度器进行分配，电梯处理请求。考虑请求输入装置、电梯和调度器是线程的Pipeline 模式的架构设计，以及如何实现线程交互。</li><li>电梯调度策略。电梯调度策略是指把请求分配各电梯时采取的策略，需要综合考虑电梯总运行时间、耗电量和最长等待时间等性能优化。</li><li>电梯运行策略。电梯运行策略是指电梯处理自己的请求队列采取的策略。</li></ol><h3 id="hw5-整体架构"><a href="#hw5-整体架构" class="headerlink" title="hw5 整体架构"></a>hw5 整体架构</h3><h4 id="线程设计"><a href="#线程设计" class="headerlink" title="线程设计"></a>线程设计</h4><p>本设计基于 Pipeline 模式，线程有输入装置、调度器、电梯三类。输入线程和调度器线程共享请求队列。调度器线程和电梯线程共享电梯内等待队列。如图：</p><p><img src="https://s2.loli.net/2023/04/15/uFplUvq7PaebdXK.png" alt="image-20230415150238302"></p><p>输入线程：输入线程从标准输入中获取请求，存入请求队列。</p><p>调度器线程：调度器从请求队列获取线程，根据调度策略将请求放入电梯内的等待队列。</p><p>电梯线程：电梯线程模拟电梯运行，处理电梯内等待队列的请求。</p><p>请求队列：内有 <code>requests</code> 队列和 <code>end</code>属性（用于线程终止判断）。</p><p>电梯内等待对列：内有 <code>requests</code> 队列和 <code>end</code>属性（用于线程终止判断）。除了存储获取请求外，还有一些配合电梯运行的处理。</p><h4 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h4><p>线程应该在什么时候终止是一个必须要解决的问题，否则线程一直无法终止会引发 RTLE 问题。这一部分内容有学长推荐看《图解Java多线程设计模式》中的 <strong>Two Phase Termination</strong> 这一章。我主要是通过实验代码理解。当输入结束并且请求队列为空，那么调度器线程结束；调度线程结束并且电梯处理完分配到的请求，那么电梯线程结束。在介绍每个线程的结束条件之前，我们先来看看线程是如何结束的。run 方式是线程的入口，也是线程结束的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> elevatorInput.nextRequest();</span><br><span class="line">            <span class="keyword">if</span> (request == <span class="literal">null</span>) &#123;</span><br><span class="line">                waitQueue.setEnd(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schedule</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitQueue.isEmpty() &amp;&amp; waitQueue.getEnd()) &#123;</span><br><span class="line">               elevators.setEnd();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elevator</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curInRequests.isEmpty() &amp;&amp; requestQueue.isEmpty() &amp;&amp; requestQueue.getEnd()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电梯调度策略"><a href="#电梯调度策略" class="headerlink" title="电梯调度策略"></a>电梯调度策略</h4><p>电梯调度有很多策略：</p><p>(1) 模拟电梯保证局部最优解的策略，在输入线程获得一个请求时，深克隆电梯类进行模拟从而将请求分配各所花费时间最少的电梯。</p><p>(2) 较为均衡的分配方式（第 i 位乘客分配给第 (i % 6) 座电梯），当输入请求数量较多的时候，性能上也还不错。</p><p>(3) 随机分配方式 random，其实和前者策略差不多。</p><p>(4) 自由竞争策略，所有电梯共用输入线程的请求队列，当输入一个请求时，所有电梯都努力去获取这个请求，这种策略在时间性能上占据优势，但是电量消耗会比较高。</p><p>我实现了电梯模拟策略，也就是往届所说的影子电梯。其主要思想为：对于每一个待分配的请求，“深克隆”电梯此时的状态，将请求放入电梯的等待队列，进行模拟（将上下行开门的 <code>sleep(400)</code> 改为 <code>time += 400</code>），选择最早结束的电梯接收这个请求。和周围同学比较发现这种策略在运行时间和耗电量都比较优。</p><h4 id="电梯运行策略"><a href="#电梯运行策略" class="headerlink" title="电梯运行策略"></a>电梯运行策略</h4><p>我采用了 <strong>look</strong> 算法：当电梯在往上走时，如果遇到向上的请求就捎带上，当<strong>电梯内没有乘客并且电梯前方没有等待的请求</strong>时就换方向。当到达某一楼层时，如果电梯未满并且请求与电梯运行方向一致时，就开门捎带上请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">nextState</span> <span class="operator">=</span> strategy.getStrategy(floor, direction, fullNum, curInRequests, requestQueue); <span class="comment">// strategy 获取电梯下一状态</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">switch</span> (nextState) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;open&quot;</span>:</span><br><span class="line">        openAndClose();</span><br><span class="line">        preTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;keep&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> (direction) &#123; up(); &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; down(); &#125;</span><br><span class="line">        preTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;reverse&quot;</span>:</span><br><span class="line">        direction = !direction;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;wait&quot;</span>:</span><br><span class="line">        direction = <span class="literal">true</span>;</span><br><span class="line">        requestQueue.waitRequest();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">        isEnd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>往届学长提出了“量子电梯”的概念：</p><p>当电梯在等待时，电梯的请求队列获得了请求，电梯开始运动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[time1] ARRIVE floor1</span><br><span class="line">[time2] begin wait</span><br><span class="line">[time3] end wait</span><br><span class="line">[time4] ARRIVE floor2</span><br></pre></td></tr></table></figure><p>按照一般同学们的处理，有 $time4 = time3 + 0.4$ 。</p><p>然而我们可以利用 wait 的时间，因为我们仅需保证 <code>time4 - time1 &gt; 0.4</code> 。</p><p>具体实现就是记录电梯最后一次关门、上下行的时间，然后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (currentTime - preTime &lt; speed) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(speed - currentTime + preTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    floor++;</span><br><span class="line">    TimableOutput.println(String.format(<span class="string">&quot;ARRIVE-%d-%d&quot;</span>, floor, id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hw6-amp-hw7-需求分析"><a href="#hw6-amp-hw7-需求分析" class="headerlink" title="hw6 &amp; hw7 需求分析"></a>hw6 &amp; hw7 需求分析</h3><p><strong>题目新增要求</strong>：</p><ul><li><p>楼层的特殊性（电梯停靠服务数量限制）</p></li><li><p>电梯的特殊性（电梯能够到达的楼层、电梯动态维护和新增）</p></li><li><p>调度的特殊性（换乘、捎带、队列平衡、等待时间平衡）</p></li></ul><p><strong>分析：</strong></p><ul><li>新增或维护电梯后，考虑旧电梯内原有的乘客请求如何处理。</li><li>线程的终止条件发生变化。</li><li>考虑如何限制每层楼电梯停靠的服务数量。</li><li>由于hw7出现换乘，需要重新规划电梯调度策略。</li></ul><h3 id="hw6-amp-hw7-架构的迭代变化"><a href="#hw6-amp-hw7-架构的迭代变化" class="headerlink" title="hw6 &amp; hw7 架构的迭代变化"></a>hw6 &amp; hw7 架构的迭代变化</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="https://s2.loli.net/2023/04/15/xb2aQpIzeEfZ6rM.png" alt="image-20230415153226797"></p><p><code>MainClass</code>：初始化实例和开启线程。</p><p><code>InputThread</code>：获取输入的请求</p><p><code>RequestQueue</code>：总乘客队列。</p><p><code>Schedule</code>：根据电梯调度策略，将乘客请求分配给电梯内部等待队列。</p><p><code>Elevator</code>：模拟电梯运行过程。</p><p><code>Strategy</code>：得到电梯下一状态。</p><p><code>InternalQueue</code>：电梯内等待队列。</p><p><code>Person</code>：乘客请求。</p><p><code>Floor</code>：限制楼层服务电梯数量。</p><p><code>Counter</code>：计数器，判断乘客请求是否都处理完，用于线程终止判断。</p><h4 id="电梯的新增和维护"><a href="#电梯的新增和维护" class="headerlink" title="电梯的新增和维护"></a>电梯的新增和维护</h4><p>新增 <code>ElevatorQueue</code> 类，管理电梯的新增和维护。</p><p>对于维护操作：<code>Elevator</code> 类内新增 maintain 属性。当输入线程获取到维护请求时，将响应电梯的 maintain 属性标记为 true 。当电梯线程访问 maintain 为 true 时，开门放下乘客，将所有未完成的请求返回总队列，被维护的电梯结束线程。</p><p><img src="https://s2.loli.net/2023/04/15/sXaf8vjgKRWoDY2.png" alt="image-20230415153047175"></p><p>在这里可以进行一些优化：</p><ul><li>新增电梯时，电梯队列状态发生改变，之前的调度已经不是最优解。比如说当请求已被分配完毕时，新增一部电梯，该电梯并不会运作。所以可以考虑将电梯内等待队列所有请求返回总队列进行重新调度。</li><li>维护电梯时，若电梯线程在开门状态中被通知maintain，直接放人进行维护。</li></ul><h4 id="线程的终止条件"><a href="#线程的终止条件" class="headerlink" title="线程的终止条件"></a>线程的终止条件</h4><p>在 hw5 中线程终止条件为：hw5：输入线程结束-(请求队列为空)-&gt;调度线程结束-(电梯内请求为空)-&gt;电梯线程结束。但是由于电梯可能会把请求返回给请求队列，就会产生问题：当某台电梯被维护将请求返回请求队列但电梯线程均已结束时，没有电梯可以响应请求。我们可以进一步约束线程终止条件：当<strong>输入线程结束并且所有请求都被处理完成后</strong>结束调度和电梯线程。此处判断所有请求是否处理完成可以设置一个单例模式的计数器。以下为主要进行的修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schedule</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitQueue.isEmpty() &amp;&amp; waitQueue.getEnd()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Counter.equalZero()) &#123;</span><br><span class="line">                    elevators.setEnd();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="楼层停靠服务中电梯数限制"><a href="#楼层停靠服务中电梯数限制" class="headerlink" title="楼层停靠服务中电梯数限制"></a>楼层停靠服务中电梯数限制</h4><p>该部分可以参考exp4中的信号量。信号量（Semaphore）本质上就是一个比较特殊的整数，代表了某种可用资源的剩余数量。通过信号量的加减，各线程可以申请和释放可用资源，当没有可用资源可以申请时（此时信号量为0），线程将挂起，直到别的线程释放了该信号量对应的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">openAndClose</span><span class="params">(<span class="type">boolean</span> receive)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (receive) &#123; floorHashMap.get(floor).acquireReceive(); &#125; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> &#123; floorHashMap.get(floor).acquireServe(); &#125; <span class="comment">// 开门前获取</span></span><br><span class="line">        TimableOutput.println(String.format(<span class="string">&quot;OPEN-%d-%d&quot;</span>, floor, id));</span><br><span class="line">        putOffRequests();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">400</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        putOnRequests();</span><br><span class="line">        TimableOutput.println(String.format(<span class="string">&quot;CLOSE-%d-%d&quot;</span>, floor, id));</span><br><span class="line">        <span class="keyword">if</span> (receive) &#123; floorHashMap.get(floor).releaseReceive(); &#125; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> &#123; floorHashMap.get(floor).releaseServe(); &#125; <span class="comment">// 开门后释放</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="电梯调度策略-1"><a href="#电梯调度策略-1" class="headerlink" title="电梯调度策略"></a>电梯调度策略</h4><p><strong>换乘路径搜索</strong></p><ul><li>深度优先搜索，搜到一条可达路径，就更新请求路径，把请求放入相应电梯。</li><li>广度优先搜索，搜索满足最少换乘数的可达路径。</li><li>加权最短路，考虑换乘数、电梯已有的请求数、经过的楼层数等因素进行合适的权重分配，求解加权最短路。</li></ul><p><strong>路径更新</strong></p><ul><li>静态路径更新：对于每个新请求，在调度时记录完整路径，仅当路径中电梯被维护时重新规划。</li><li>动态路径更新：每次路径规划仅记录 nextToFloor，当请求下电梯但未到达目的地时，就放回总队列重新调度。</li></ul><h3 id="架构中的变与不变"><a href="#架构中的变与不变" class="headerlink" title="架构中的变与不变"></a>架构中的变与不变</h3><p><img src="https://s2.loli.net/2023/04/15/CD94IAgWibus1cp.png" alt="image-20230415154802723"></p><p>在迭代中可以发现，整体架构并没有发生改变，电梯运行也没有发生改变。由于新增电梯操作而新增了电梯队列类并对电梯队列进行维护，线程终止条件也由于请求可能需要返回请求队列重新分配而进一步约束。调度算法发生改变。楼层停靠服务电梯数的限制需要新增 Floor 类进行管理。</p><p><strong>如何让频繁变化的设计稳定下来</strong>：</p><ol><li><p>提高程序架构的可扩展性</p><ul><li>设计能够面向未来扩展</li><li>eg. 电梯可动态变化，电梯参数可变，设置电梯队列类。</li></ul></li><li><p>分层架构</p><ul><li>分层架构的核心是隔离，将不同职责的对象划分到不同的层中实现。</li><li>输入装置 | 调度器 请求队列 电梯队列 | 电梯 电梯内等待队列</li></ul></li><li><p>遵循单一职责原则</p><ul><li>每个模块只负责自己的事情，而不是变成万能的。</li><li>eg. 输入线程获取到维护电梯请求时，仅将电梯维护属性设为 true和从电梯队列中删除，由电梯线程自行维护，而非直接处理电梯请求。</li></ul></li><li><p>高内聚低耦合设计</p><ul><li><p>内聚是从功能角度来度量模块内的联系；耦合是软件结构中各模块之间相互连接的一种度量。高内聚低耦合设计可以有效提高代码的可读性和可维护性，降低软件复杂度。</p><ul><li><p>简化接口设计</p><ul><li><p>只对外暴露最小限度的接口。</p></li><li><p>把简单留给别人，把复杂留给自己。</p></li><li><p>```java<br>public class Schedule {</p><pre><code>private final ElevatorQueue elevators;public void run() &#123;    ...    Person person = requestQueue.getPerson();    Integer elevatorId = getPersonPath(person);    elevators.get(elevatorId).addPerson(person);&#125;private int getPersonPath(Person person) &#123;    // 加权最短路求解路径    // 更新 person 的 nextToFloor    // 返回 person 需乘坐的电梯 ID&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 隐藏实现细节</span><br><span class="line"></span><br><span class="line">  - 只给调用者暴露重要的信息，把不重要的细节隐藏起来。</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public class InternalQueue() &#123;</span><br><span class="line">        // 方案一</span><br><span class="line">        public synchronized Vector&lt;Person&gt; getPeoPle(</span><br><span class="line">            int floor, boolean direction, int resCapacity) &#123;</span><br><span class="line">            // 返回能上电梯的乘客，并将其从等待队列删除</span><br><span class="line">        &#125;</span><br><span class="line">        // 方案二</span><br><span class="line">        public Vector&lt;Person&gt; getPeoPle() &#123;</span><br><span class="line">            // 返回整个等待队列</span><br><span class="line">        &#125;</span><br><span class="line">        // 电梯调用该方法获取等待队列，选择能上电梯的乘客，并将其从等待队列删除</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ol><h2 id="线程的互斥与协作"><a href="#线程的互斥与协作" class="headerlink" title="线程的互斥与协作"></a>线程的互斥与协作</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全（thread-safe）是关于对象是否能被多个线程安全访问的特性。如果一个对象是线程安全的，则无论多个线程以什么样的交叠次序来访问都不会影响该对象的行为结果。</p><p>如何会导致线程不安全：</p><ul><li>读写冲突<ul><li>check-then-act</li><li>read-modify-write</li></ul></li><li>写写冲突（覆盖）</li></ul><p>线程安全的设计考虑：</p><ul><li>使用不可变对象</li><li>使用可变对象<ul><li>操作的原子性</li><li>共享对象要始终处于严密控制之下</li><li>设置范围适当的临界区（临界区最小化）</li><li>使用合适的监控器</li></ul></li></ul><p>此外，对象共享是产生线程安全问题的根本原因。在思考某一部分代码是否会产生线程安全问题时，可以思考其是否会被多个线程访问，线程访问的读写关系等。</p><h3 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h3><p>一个实例中的 synchronized 方法每次只能由一个线程运行，对非 synchronized 方法没有影响。</p><p>每个实例拥有独立的锁。</p><p>只在共享对象中设置同步块，仅使用同步块中的共享对象来守护该同步块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 代码块</span></span><br><span class="line"><span class="keyword">synchronized</span>(expr) &#123; <span class="comment">// expr 为获取锁的实例</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized 实例方法和 synchronized 代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> method &#123; <span class="comment">// 使用this的锁来执行线程的互斥处理</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> method &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上文线程安全的内容可知，当对象会被多个线程读写时需要进行互斥操作。在我的设计中，线程互斥主要在请求队列和电梯内的等待队列这两个共享对象实现，主要是通过 synchronized 方法。</p><h4 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h4><p>wait, notify, notifyAll 都是 java.lang.Object 类的方法。</p><p>每个实例都拥有一个等待队列，放置在执行实例的 wait 方法后停止操作的线程。</p><p>若要执行 wait, notify, notifyAll 操作，线程必须持有锁。如果线程进入等待队列，便会释放其实例的锁。</p><p>notifyall 唤醒在该实例中等待的线程时，并不是立即让锁，而是先执行完当前方法中的语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj.wait(); <span class="comment">// 线程正在obj上等待</span></span><br><span class="line">wait; <span class="comment">// 线程正在this上等待</span></span><br><span class="line"><span class="built_in">this</span>.wait(); <span class="comment">// 线程正在this上等待</span></span><br><span class="line"></span><br><span class="line">obj.notifyAll(); <span class="comment">// 在obj实例的等待队列中休眠的所有线程都会被唤醒 </span></span><br><span class="line">notifyAll(); <span class="comment">// 在this实例的等待队列中休眠的所有线程都会被唤醒 </span></span><br><span class="line"><span class="built_in">this</span>.notifyAll(); <span class="comment">// 在this实例的等待队列中休眠的所有线程都会被唤醒 </span></span><br></pre></td></tr></table></figure><p>当某个线程卡在临界区或一直获取不到资源时，会发生轮询，会比较耗费CPU。当你提交时如果遇到 CTLE 可以考虑代码中是否有轮询。比如说当 Schedule 想要获取乘客请求时，waitQueue 为空，此时我们可以让该线程进入 waitQueue 的等待队列，也就是让它 wait 一下。当 waitQueue 非空（即输入线程把乘客请求给了 waitQueue）时，唤醒 waitQueue 的等待队列 （notifyAll）。该部分可以参考 Producer-Consumer 模式或 Guard Suspension 模式。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><div class="table-container"><table><thead><tr><th>class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Cell</td><td>1.0</td><td>1.0</td><td>11.0</td></tr><tr><td>Compare</td><td>2.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Counter</td><td>1.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Elevator</td><td>2.7142857142857144</td><td>13.0</td><td>38.0</td></tr><tr><td>ElevatorQueue</td><td>2.1666666666666665</td><td>4.0</td><td>13.0</td></tr><tr><td>Floor</td><td>1.0</td><td>1.0</td><td>5.0</td></tr><tr><td>InputThread</td><td>3.5</td><td>6.0</td><td>7.0</td></tr><tr><td>MainClass</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Person</td><td>1.0</td><td>1.0</td><td>8.0</td></tr><tr><td>RequestQueue</td><td>2.090909090909091</td><td>5.0</td><td>23.0</td></tr><tr><td>Schedule</td><td>6.666666666666667</td><td>14.0</td><td>20.0</td></tr><tr><td>Strategy</td><td>4.333333333333333</td><td>8.0</td><td>13.0</td></tr><tr><td>WaitQueue</td><td>1.5</td><td>4.0</td><td>12.0</td></tr><tr><td>Total</td><td></td><td></td><td>156.0</td></tr><tr><td>Average</td><td>2.0526315789473686</td><td>4.6923076923076925</td><td>12.0</td></tr></tbody></table></div><p><code>Elevator</code> 需要向 <code>Strategy</code> 类传入电梯参数从而获得电梯下一刻状态，耦合度比较高，并且电梯的状态更新比较多导致run 方法比较复杂。<code>Schedule</code> 类需要通过 dijkstra 算法求解最短路径并更新乘客请求这里复杂度比较高。</p><h3 id="多线程程序的-debug-方式"><a href="#多线程程序的-debug-方式" class="headerlink" title="多线程程序的 debug 方式"></a>多线程程序的 debug 方式</h3><ul><li>利用调试功能。可以根据输出大致判断出bug触发地，据此选定断点。比如说电梯门开了之后乘客却没有进来，此时就将断点设置在开门的方法。</li><li>利用 printf 输出。可以输出电梯状态改变、请求状态改变（进入等待队列等信息）、线程状态改变以及观察时间戳等判断。</li><li>有同学跟我分享了一种方法：设置一个 Debug 类，通过 stderr 抛出异常，这样也不会影响输出检测。</li></ul><h3 id="程序中出现的-bug"><a href="#程序中出现的-bug" class="headerlink" title="程序中出现的 bug"></a>程序中出现的 bug</h3><ul><li>线程的互斥。电梯队列由输入线程管理，会被调度线程分配请求时访问。一开始没有对其进行互斥处理。</li></ul><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><h3 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h3><p>处理好线程安全的关键时判断清楚对象是否会被多个线程访问，然后进行互斥操作。在本次作业中我主要采用 synchronized 进行互斥，并没有用到读写锁，因为其对性能影响不大，就没有改变原有设计。</p><h3 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h3><p>层次清晰的架构可以更容易理清每个模块的职责，易于实现高内聚低耦合。那么当需要迭代更新时就可以方便的将要求拆分到具体的层次中处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Object Oriented </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA OS Lab2实验报告</title>
      <link href="/2023/04/04/Lab2/"/>
      <url>/2023/04/04/Lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab2-实验报告"><a href="#Lab2-实验报告" class="headerlink" title="Lab2 实验报告"></a>Lab2 实验报告</h1><p>关键词：物理内存的管理方法（链表法），虚拟内存的管理方法（两级页表法），TLB清除与重填</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h5 id="2-1-请根据上述说明，回答问题：在编写的-C-程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS-汇编程序中-lw-和-sw-使用的是虚拟地址，还是物理地址？"><a href="#2-1-请根据上述说明，回答问题：在编写的-C-程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS-汇编程序中-lw-和-sw-使用的是虚拟地址，还是物理地址？" class="headerlink" title="2.1 请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 使用的是虚拟地址，还是物理地址？"></a>2.1 请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 使用的是虚拟地址，还是物理地址？</h5><p>均为虚拟地址</p><h5 id="2-2-请思考下述两个问题：①-从可重用性的角度，阐述用宏来实现链表的好处。②查看实验环境中的-usr-include-sys-queue-h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。"><a href="#2-2-请思考下述两个问题：①-从可重用性的角度，阐述用宏来实现链表的好处。②查看实验环境中的-usr-include-sys-queue-h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。" class="headerlink" title="2.2 请思考下述两个问题：① 从可重用性的角度，阐述用宏来实现链表的好处。②查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。"></a>2.2 请思考下述两个问题：① 从可重用性的角度，阐述用宏来实现链表的好处。②查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</h5><p>① 实现了C语言不支持的泛型。宏函数参数type的使用实现自定义数据类型的链表，通过各种宏定义实现链表的基本操作。</p><blockquote><p>C++ 中可以使用 std::stack<T> 定义一个类型为 T 的栈，Java 中可以使用 HashMap<K,V></p><p>定义一个键类型为 K 且值类型为 V 的哈希表。这种模式称为泛型，C 语言并没有泛型的语法，因</p><p>此需要通过宏另辟蹊径来实现泛型。</p></blockquote><p>② </p><div class="table-container"><table><thead><tr><th></th><th>插入操作</th><th>删除操作</th></tr></thead><tbody><tr><td>单向链表</td><td>头部插入O(1), 尾部插入O(n)，指定节点前O(n)，指定节点后O(1)</td><td>头部删除O(1)，指定节点O(n)</td></tr><tr><td>循环链表</td><td>头部插入O(1), 尾部插入O(1)，指定节点前O(1)，指定节点后O(1)</td><td>头部删除O(1)，指定节点O(1)</td></tr><tr><td>双向链表</td><td>头部插入O(1), 尾部插入O(n)，指定节点前O(1)，指定节点后O(1)</td><td>头部删除O(1)，指定节点O(1)</td></tr></tbody></table></div><p>空间性能：单向链表&lt;双向链表&lt;循环链表</p><p>时间性能：循环链表&lt;双向链表&lt;单向链表</p><h5 id="2-3-Page-list-的展开结构"><a href="#2-3-Page-list-的展开结构" class="headerlink" title="2.3 Page_list 的展开结构"></a>2.3 Page_list 的展开结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">&#125; pp_link; <span class="comment">// 对应的链表项</span></span><br><span class="line">u_short pp_ref; <span class="comment">// 这一页物理内存被引用的次数，等于有多少虚拟页映射到该物理页</span></span><br><span class="line">&#125;* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-请思考下面两个问题：①-请阅读上面有关-R3000-TLB-的描述，从虚拟内存的实现角度，阐述-ASID-的必要性。②-请阅读《IDT-R30xx-Family-Software-Reference-Manual》的-Chapter-6，结合-ASID段的位数，说明-R3000-中可容纳不同的地址空间的最大数量。"><a href="#2-4-请思考下面两个问题：①-请阅读上面有关-R3000-TLB-的描述，从虚拟内存的实现角度，阐述-ASID-的必要性。②-请阅读《IDT-R30xx-Family-Software-Reference-Manual》的-Chapter-6，结合-ASID段的位数，说明-R3000-中可容纳不同的地址空间的最大数量。" class="headerlink" title="2.4 请思考下面两个问题：① 请阅读上面有关 R3000-TLB 的描述，从虚拟内存的实现角度，阐述 ASID 的必要性。② 请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。"></a>2.4 请思考下面两个问题：① 请阅读上面有关 R3000-TLB 的描述，从虚拟内存的实现角度，阐述 ASID 的必要性。② 请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。</h5><p>① ASID 用于区分不同的地址空间，因为同一虚拟地址在不同的地址空间中通常映射到不同的物理地址。ASID能在多进程操作系统中访存更加安全。</p><p>② ASID 长度为6位，可以容纳不同地址空间的最大数量即为64。每个进程对应唯一的 ASID，则处理器可支持64个并发进程。</p><h5 id="请回答下述三个问题：①-tlb-invalidate-和-tlb-out-的调用关系？②-请用一句话概括-tlb-invalidate-的作用。③-逐行解释-tlb-out-中的汇编代码。"><a href="#请回答下述三个问题：①-tlb-invalidate-和-tlb-out-的调用关系？②-请用一句话概括-tlb-invalidate-的作用。③-逐行解释-tlb-out-中的汇编代码。" class="headerlink" title="请回答下述三个问题：① tlb_invalidate 和 tlb_out 的调用关系？② 请用一句话概括 tlb_invalidate 的作用。③ 逐行解释 tlb_out 中的汇编代码。"></a>请回答下述三个问题：① tlb_invalidate 和 tlb_out 的调用关系？② 请用一句话概括 tlb_invalidate 的作用。③ 逐行解释 tlb_out 中的汇编代码。</h5><p>tlb_invalidate 调用 tlb_out，实现删除特定虚拟地址在 TLB 中的旧表项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br><span class="line">.set noreorder</span><br><span class="line">mfc0    t0, CP0_ENTRYHI // t0 = CP0_ENTRYHI</span><br><span class="line">mtc0    a0, CP0_ENTRYHI // CP0_ENTRYHI = a0</span><br><span class="line">nop // 解决数据冒险(tlbq)</span><br><span class="line">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span><br><span class="line">/* Exercise 2.8: Your code here. (1/2) */</span><br><span class="line">tlbp // 根据 ENTRYHI 中的 key 查找对应的旧表项，将表项的索引存入 Index</span><br><span class="line">nop // 解决数据冒险(tlbq)</span><br><span class="line">/* Step 2: Fetch the probe result from CP0.Index */</span><br><span class="line">mfc0    t1, CP0_INDEX // t1 = CP0_INDEX</span><br><span class="line">.set reorder</span><br><span class="line">bltz    t1, NO_SUCH_ENTRY // 若索引值&gt;=0（即TLB中存在 key 对应的表项），则向 ENTRYHI 和 ENTRYLO中写入0</span><br><span class="line">.set noreorder</span><br><span class="line">mtc0    zero, CP0_ENTRYHI</span><br><span class="line">mtc0    zero, CP0_ENTRYLO0</span><br><span class="line">nop</span><br><span class="line">/* Step 3: Use &#x27;tlbwi&#x27; to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span><br><span class="line">/* Exercise 2.8: Your code here. (2/2) */</span><br><span class="line">tlbwi // 将 ENTRYHI, EHTRYLO 中的值写入索引指定的表项</span><br><span class="line">.set reorder</span><br><span class="line"></span><br><span class="line">NO_SUCH_ENTRY:</span><br><span class="line">mtc0    t0, CP0_ENTRYHI // CPO_ENTRYHI = t0 恢复为原始值，以便后续指令能正确访问虚拟地址</span><br><span class="line">j       ra</span><br><span class="line">END(tlb_out)</span><br></pre></td></tr></table></figure><h5 id="2-5-在现代的-64-位系统中，提供了-64-位的字长，但实际上不是-64-位页式存储系统。假设在-64-位系统中采用三级页表机制，页面大小-4KB。由于-64-位系统中字长为8B，且页目录也占用一页，因此页目录中有-512-个页目录项，因此每级页表都需要-9-位。因此在-64-位系统下，总共需要-3-×-9-12-39-位就可以实现三级页表机制，并不需要-64位。现考虑上述-39-位的三级页式存储系统，虚拟地址空间为-512-GB，若三级页表的基地址为-PTbase，请计算：三级页表页目录的基地址。映射到页目录自身的页目录项（自映射）。"><a href="#2-5-在现代的-64-位系统中，提供了-64-位的字长，但实际上不是-64-位页式存储系统。假设在-64-位系统中采用三级页表机制，页面大小-4KB。由于-64-位系统中字长为8B，且页目录也占用一页，因此页目录中有-512-个页目录项，因此每级页表都需要-9-位。因此在-64-位系统下，总共需要-3-×-9-12-39-位就可以实现三级页表机制，并不需要-64位。现考虑上述-39-位的三级页式存储系统，虚拟地址空间为-512-GB，若三级页表的基地址为-PTbase，请计算：三级页表页目录的基地址。映射到页目录自身的页目录项（自映射）。" class="headerlink" title="2.5 在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：三级页表页目录的基地址。映射到页目录自身的页目录项（自映射）。"></a>2.5 在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 <em>×</em> 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：三级页表页目录的基地址。映射到页目录自身的页目录项（自映射）。</h5><p>三级页表的基地址为PTbase（即虚拟内存第一个页表项的地址），其所在页为 PTbase &gt;&gt; 12。第二级页表的基地址 PTbase + PTbase &gt;&gt; 12 &lt;&lt; 3 = PTbase + PTbase &gt;&gt; 9。那么一级页表的基地址为 PTbase + PTbase &gt;&gt; 9 + PTbase &gt;&gt; 18。</p><p>映射到页目录自身的页目录项即为 PDEbase = PTbase + PTbase &gt;&gt; 9 + PTbase &gt;&gt; 18 + PTbase &gt;&gt; 27。</p><h5 id="2-6-①-简单了解并叙述-X86-体系结构中的内存管理机制，比较-X86-和-MIPS-在内存管理上的区别。②-简单了解并叙述-RISC-V-中的内存管理机制，比较-RISC-V-与-MIPS-在内存管理上的区别。"><a href="#2-6-①-简单了解并叙述-X86-体系结构中的内存管理机制，比较-X86-和-MIPS-在内存管理上的区别。②-简单了解并叙述-RISC-V-中的内存管理机制，比较-RISC-V-与-MIPS-在内存管理上的区别。" class="headerlink" title="2.6 ① 简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。② 简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。"></a>2.6 ① 简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。② 简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</h5><p>① x86主要为为段页式内存管理机制，更有利于内存保护和共享。而MIPS作为一种精简的指令集体系结构，主要采用分页式内存管理机制和单一地址空间模型，即将内存地址空间分为用户空间和内核空间。</p><h3 id="函数定义分析"><a href="#函数定义分析" class="headerlink" title="函数定义分析"></a>函数定义分析</h3><ul><li><code>mips_detect_memory()</code>: kern/pmap.c，探测硬件可用内存，并对一些和内存管理相关的变量进行初始化</li><li><code>mips_vm_init()</code>：kern/pmap.c，在探测完可用内存后，将开始建立内存管理机制。<ul><li><code>alloc</code>：kern/pmap.c，分配内存空间（在建立页式内存管理机制之前使用）。分配 n 字节的空间并返回初始的虚拟地址，同时将地址按 align 字节对齐（保证 align 可以整除初始虚拟地址），若 clear 为真，则将对应内存空间的值清零，否则不清零。</li></ul></li><li><code>page_init()</code></li><li><code>ROUND(a,n)</code> :一个定义在 include/types.h 的宏，作用是返回 ⌈a\n⌉ n（将 a 按 n 向上对齐），要求 n 必须是 2 的非负整数次幂。</li><li><code>ROUNDDOWN(a, n)</code> : 下取整</li><li><code>PPN(va)</code> ：得到某个虚拟地址的页号。</li><li><code>PADDR(x)</code>：include/mmu.h，将某个内核虚拟地址x转化为物理地址。（该宏要求x必须是kseg0中的虚拟地址）</li><li><code>KADDR</code>：include/mmu.h，返回物理地址 x 所位于 kseg0 的虚拟地址。</li><li><code>page2kva(pp)</code> ：得到 Page pp 的内核虚拟地址</li><li><code>page2pa(pp)</code> ：得到 Page pp 的物理地址 </li><li><code>pa2page(pa)</code> ：得到物理地址 pa 所对应的 Page 结构体（读取pte后可进行转换）</li><li><code>PPN(va)</code> ：得到虚拟地址 va 的页号</li><li><code>page2ppn(pp)</code>：得到 Page pp 的页号</li><li><code>memset(void *dst, int c, size_t n)</code> ：eg. memset((void *)alloced_mem, 0, n)。</li></ul><h3 id="链表宏"><a href="#链表宏" class="headerlink" title="链表宏"></a>链表宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">le_next</span>;</span> <span class="comment">// 指向下一个元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">le_prev</span>;</span> <span class="comment">// 指向前一个元素链表项 le_next （当删除一个元素时，更改前一个元素链表项的le_next）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于往链表中插入元素操作解释如图（其中黄线表示需要进行的操作，操作顺序不一定如图。）</p><p><img src="https://s2.loli.net/2023/03/21/MYC5ZTfA2tzocb7.png" alt="image-20230321112349534"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> * Hint:</span><br><span class="line"> * Step <span class="number">1</span>: assign <span class="string">&#x27;elm.next&#x27;</span> from <span class="string">&#x27;listelm.next&#x27;</span>.</span><br><span class="line"> * Step <span class="number">2</span>: <span class="keyword">if</span> <span class="string">&#x27;listelm.next&#x27;</span> is not <span class="literal">NULL</span>, then assign <span class="string">&#x27;listelm.next.pre&#x27;</span> from a proper value.</span><br><span class="line"> * Step <span class="number">3</span>: assign <span class="string">&#x27;listelm.next&#x27;</span> from a proper value.</span><br><span class="line"> * Step <span class="number">4</span>: assign <span class="string">&#x27;elm.pre&#x27;</span> from a proper value.</span><br><span class="line"> */</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field)                                                     \</span></span><br><span class="line"><span class="meta"><span class="comment">/* Exercise 2.2: Your code here. */</span> \</span></span><br><span class="line"><span class="meta">do &#123;\</span></span><br><span class="line"><span class="meta">LIST_NEXT((elm), field) = LIST_NEXT((listelm), field);\</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (LIST_NEXT((listelm), field) != NULL) \</span></span><br><span class="line"><span class="meta">LIST_NEXT((listelm), field)-&gt;field.le_prev = &amp;(LIST_NEXT((elm), field));\</span></span><br><span class="line"><span class="meta">LIST_NEXT((listelm), field) = (elm);\</span></span><br><span class="line"><span class="meta">(elm)-&gt;field.le_prev = &amp;(LIST_NEXT((listelm), field));\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><h3 id="页控制块"><a href="#页控制块" class="headerlink" title="页控制块"></a>页控制块</h3><blockquote><p>npage 个 Page 和 npage 个物理页面一一顺序对应，具体来说，npage 个 Page 的起始地址为 pages，则 pages[i] 对应从 0 开始计数的第 i 个物理页面。两者的转换可以使用 include/pmap.h 中的 page2pa 和 pa2page 这两个函数。</p></blockquote><p><code>page_free_list</code> : 空闲链表。（当一个进程需要分配内存时，将空闲链表头部的页控制块对应的那一页物理内存分配出去，同时将该页控制块从空闲链表的头部删去。）</p><p><code>freemem</code>：小于 freemem 对应物理地址的物理内存都已经被分配完了。（freemem是虚拟地址）</p><p><strong>pmap.c page_alloc 函数注意点</strong></p><p><code>memset(void *dst, int c, size_t n);</code>：第一个参数应为Page pp指向页面的虚拟地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*new = pp; <span class="comment">// new地址的内容为pp</span></span><br><span class="line">new = &amp;pp; <span class="comment">// new指针指向pp所在地址</span></span><br></pre></td></tr></table></figure><h3 id="为什么内核初始化的时候要把内核用到的物理页面pp-ref置1？"><a href="#为什么内核初始化的时候要把内核用到的物理页面pp-ref置1？" class="headerlink" title="为什么内核初始化的时候要把内核用到的物理页面pp_ref置1？"></a>为什么内核初始化的时候要把内核用到的物理页面pp_ref置1？</h3><p>物理页面的pp_ref通常用于跟踪物理页面的使用情况。当一个物理页面被映射到虚拟页表时，pp_ref会增加；删除映射关系后，pp_ref减1。如果此时pp_ref等于0就将这个物理页再添加到空闲物理页面链表里（即页面被释放）。在内核初始化期间，将内核需要使用的物理页面的pp_ref计数值设置为1，就是为了确保这些页面不会被释放，从而保证内核代码和数据的完整性和可靠性。</p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p><code>PDX(va)</code> : 获取虚拟地址 va 的 31-22位(一级页表偏移)</p><p><code>PTX(va)</code> : 获取虚拟地址 va 的 21-12 位（二级页表偏移）</p><p><code>PTE_ADDR(pte)</code>: 获取页表项中的物理地址</p><p>在 Exercise 2.6时需要注意MIPS R3000 发出的地址均为虚拟地址，因此如果程序想访问某个物理地址，需要通过映射到该物理地址的虚拟地址来访问。对页表进行操作时处于内核态，因此使用宏 KADDR 获得其位于 kseg0 中的虚拟地址即可完成转换。</p><p><img src="https://s2.loli.net/2023/04/04/K6y1lOYvRqzbjsr.png" alt="image-20230327201609483"></p><h2 id="课上"><a href="#课上" class="headerlink" title="课上"></a>课上</h2><h3 id="exam"><a href="#exam" class="headerlink" title="exam"></a>exam</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>对于给定的页目录 <code>pgdir</code>，统计其包含的所有二级页表中满足以下条件的页表项：</p><ol><li>页表项有效；</li><li>页表项映射的物理地址为给定的 <code>Page *pp</code> 对应的物理地址；</li><li>页表项的权限包含给定的权限 <code>perm_mask</code>。</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>pgdir</code> 应该理解为给定的页目录基地址，我们需要遍历所有页目录及其对应的所有二级页表项，统计满足条件的二级页表项的个数。另外注意需要判断页目录的有效性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">u_int <span class="title function_">page_perm_stat</span><span class="params">(Pde *pgdir, <span class="keyword">struct</span> Page *pp, u_int perm_mask)</span> &#123;</span><br><span class="line"><span class="comment">// count：统计满足条件的页表项的数量</span></span><br><span class="line">u_int count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历页目录项</span></span><br><span class="line"><span class="keyword">for</span> (u_long i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 当前页目录项地址 pgdir_entryp = 页目录基地址 + 页内偏移</span></span><br><span class="line">Pde *pgdir_entryp = pgdir + i;</span><br><span class="line"><span class="comment">// 判断当前页目录是否有效</span></span><br><span class="line"><span class="keyword">if</span> (*pgdir_entryp &amp; PTE_V) &#123;</span><br><span class="line"><span class="comment">// 当前二级页表页基地址 pgtab_entryb = 当前页目录项指向的物理页号对应的虚拟地址</span></span><br><span class="line">Pte *pgtab_entryb = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp)); <span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (u_long j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line"><span class="comment">// 当前页表项地址 pte = 当前页表页基地址 + 页内偏移</span></span><br><span class="line">Pte *pte = pgtab_entryb + j;</span><br><span class="line"><span class="comment">// 判断条件 1 和条件 2</span></span><br><span class="line"><span class="keyword">if</span> ((*pte &amp; PTE_V) &amp;&amp; (page2pa(pp) == PTE_ADDR(*pte))) &#123;</span><br><span class="line"><span class="comment">// 判断条件 3</span></span><br><span class="line"><span class="keyword">if</span> (((*pte) &amp; perm_mask) == perm_mask) count ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p><em>extra 挂了，发现只是因为忘了 memcpy复制的时候，需要把 page \</em>p 转换为虚拟地址 page2kva(p)。*</p><h4 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h4><p>在理论课程中，我们学习了<strong>交换</strong>技术。它实现进程在内存与外存之间的交换，因而获得更多的虚拟内存空间。</p><p>简单来说，交换空间（swap）是外存上的一块区域，当系统物理内存不足时，内核会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中。这样相当于我们获得了更多的虚拟存储（通过使用一部分外存）。</p><p>在本题中，我们会实现一个较为简单的交换机制，使得在没有空闲的物理页面时，可以暂时将正在使用的一页内存换出，同时释放出一页物理页面用于使用。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们建立的交换机制可以分为两部分，“换入”部分，以及“换出”部分。</p><p>当我们没有空闲的物理页面时，我们进行“换出”，即申请物理页面时，如果没有可用的页面，我们换出一页正在使用的物理页，供申请者使用。</p><p>当我们需要访问某个 kuseg 段的虚拟地址时，我们会检查这个虚拟地址对应的虚拟页是否已被换出到外存，如果是，则我们将其“换入”。</p><blockquote><p>虚拟页被换入的物理页可能与其被换出时不同，但需要保证换入后<strong>物理页中的数据</strong>以及<strong>页表项中的权限位</strong>与换出时相同。为此，我们需要在换出时利用外存来保存数据。</p></blockquote><h4 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h4><p>在本题中，你需要使用物理地址属于 <code>[0x3900000, 0x3910000)</code> 的这 16 个物理页以及外存来实现“交换”。</p><ul><li>在本题中我们把这 16 个物理页叫做<strong>可交换</strong>的物理页。</li><li>为了区分这些<strong>可交换</strong>的物理页，我们建立了一个新的<strong>空闲可交换页面链表</strong> <code>page_free_swapable_list</code>。</li></ul><p>同时，我们将提供部分代码（请参看<strong>实验提供代码</strong>部分），你需要将其粘贴至 <code>kern/pmap.c</code> 之后，并补全或者实现如下几个函数：</p><h5 id="换出部分（struct-Page-swap-alloc-Pde-pgdir-u-int-asid-）"><a href="#换出部分（struct-Page-swap-alloc-Pde-pgdir-u-int-asid-）" class="headerlink" title="换出部分（struct Page *swap_alloc(Pde *pgdir, u_int asid)）"></a>换出部分（<code>struct Page *swap_alloc(Pde *pgdir, u_int asid)</code>）</h5><p>本函数的功能为：</p><ul><li>当存在<strong>空闲</strong>且<strong>可交换</strong>的物理页（<code>page_free_swapable_list</code> 链表非空），只需从 <code>page_free_swapable_list</code> 中取出头部并返回。</li><li>若不存在空闲且可交换的物理页（<code>page_free_swapable_list</code>链表为空），需要从 <code>[0x3900000, 0x3910000)</code> 中选取一个物理页，将其换出到外存，并将其返回。<ul><li>本题不限制页面置换的策略，也就是说，你可以使用任意策略来选取一个物理页，将其换出到外存。</li></ul></li></ul><p><strong>注意</strong>：</p><ul><li>实验提供代码中的 <code>swap_init</code> 函数将 <code>[0x3900000, 0x3910000)</code> 对应的 <code>Page</code> 结构体从 <code>page_free_list</code> 中移除并插入到 <code>page_free_swapable_list</code> 中。因此，<code>swap_alloc</code> 所返回的 <code>Page</code> 对应的物理页，其物理地址必须是处于 <code>[0x3900000, 0x3910000)</code> 中的。</li><li>我们<strong>保证</strong>：在每次测试中，传入的 <code>pgdir</code> 和 <code>asid</code> 是<strong>唯一</strong>的。</li></ul><h5 id="换入部分（void-swap-lookup-Pde-pgdir-u-int-asid-u-long-va-）"><a href="#换入部分（void-swap-lookup-Pde-pgdir-u-int-asid-u-long-va-）" class="headerlink" title="换入部分（void swap_lookup(Pde *pgdir, u_int asid, u_long va)）"></a>换入部分（<code>void swap_lookup(Pde *pgdir, u_int asid, u_long va)</code>）</h5><p>本函数的功能为：</p><ul><li>当地址空间 <code>asid</code> 中的虚拟地址 <code>va</code> 在页目录 <code>pgdir</code> 中存在映射，但对应物理页面被换出时，调用 <code>swap</code> 函数将其换入</li><li>调用 <code>page_lookup</code> 函数，返回 <code>va</code> 对应的页表项</li></ul><p><strong>注意</strong>：</p><ul><li>我们<strong>保证</strong>：在每次测试中，传入的 <code>pgdir</code> 和 <code>asid</code> 是<strong>唯一</strong>的</li><li>传入的 <code>va</code> <strong>不一定</strong>是页对齐的。</li></ul><p>本函数的实现已经给出，你需要实现该函数中调用的 <code>swap</code> 函数和 <code>is_swapped</code> 函数。</p><ul><li><code>int is_swapped(Pde *pgdir, u_long va)</code><ul><li>本函数的功能为：当虚拟地址 <code>va</code> 在页目录 <code>pgdir</code> 中存在映射且对应物理页面被换出时，返回非 <code>0</code> 值，否则返回 <code>0</code>。</li></ul></li><li><code>void swap(Pde *pgdir, u_int asid, u_long va)</code><ul><li>本函数的调用者需保证虚拟地址 <code>va</code> 映射到的物理页已被换出到外存。</li><li>本函数的具体功能为：将页目录 <code>pgdir</code> 中虚拟地址 <code>va</code> 映射的物理页从外存中换入内存，并且更新其对应的页表项。换入时需要使用 <code>swap_alloc</code> 来申请一个物理页。其中 <code>asid</code> 参数用于传递给 <code>swap_alloc</code> 函数、更新页表时无效化对应的 TLB 表项。</li></ul></li></ul><h4 id="外存模拟部分"><a href="#外存模拟部分" class="headerlink" title="外存模拟部分"></a>外存模拟部分</h4><p>由于还没有学习如何访问外存，我们使用一个数组 <code>swap_disk</code> 来模拟外存（大小为 64 个物理页大小）。</p><p>我们使用如下两个接口函数来申请、释放外存空间：</p><ul><li><p>```<br>u_char *disk_alloc()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 申请一页大小的外存空间（页对齐），返回值为这片空间的起始地址。外存空间的一页大小为 4096 字节，与内存中的页大小一致。</span><br><span class="line">    - 返回的地址为 kseg0 段的，指向 `swap_disk` 数组内空间的地址。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  void disk_free(u_char* da)</span><br></pre></td></tr></table></figure><ul><li>释放 <code>da</code> 起始的一页外存空间。</li></ul></li></ul><h4 id="设计提示"><a href="#设计提示" class="headerlink" title="设计提示"></a>设计提示</h4><p>我们给出一种可行的设计，当然，你也可以略过本节自己进行设计。</p><p>当没有空闲的物理页时，我们需要进行换出操作。在本设计中，我们在页表项中增加了一个新的标志位 <code>PTE_SWP</code>（在下发的头文件 <code>swap.h</code> 中已有定义）。</p><ul><li>当 <code>PTE_SWP</code> 为 <code>1</code> 且 <code>PTE_V</code> 为 <code>0</code> 时:<ul><li>对应的虚拟地址映射到的物理内存<strong>有效但被换出</strong>，实际的内容存在外存上，该页表项的高 20 位为内容在外存上的外存页号。</li></ul></li><li>软件应保证不会出现 <code>PTE_SWP</code> 为 <code>1</code> 且 <code>PTE_V</code> 为 <code>1</code> 的页表项。</li><li>当 <code>PTE_SWP</code> 为 <code>0</code> 时，页表项的含义与 Lab2 课下定义的相同。</li><li>我们可以通过 <code>da / BY2PG</code> 计算 <code>da</code> 对应的外存页号</li></ul><p>当我们希望将某个虚拟地址对应的物理页从外存中换入内存时：</p><ol><li>使用 <code>swap_alloc</code> 申请一个物理页 <code>p</code></li><li>将外存中以 <code>da</code> 起始的一页内容拷贝到该物理页 <code>p</code> 上（<code>da</code> 为换出时内容在外存上的地址）</li><li>对指定页表中，所有“ <code>PTE_SWP</code> 为 <code>1</code> 且 <code>PTE_V</code> 为 <code>0</code> 且高 20 位为 <code>da</code> 对应的外存页号”的页表项，做如下操作：<ol><li>将 <code>PTE_V</code> 置 <code>1</code></li><li>将 <code>PTE_SWP</code> 置 <code>0</code></li><li>在高 20 位中填入 <code>p</code> 对应的物理页号</li><li>维持其它权限位不变</li><li>无效化旧 TLB 表项</li></ol></li><li>使用 <code>disk_free</code> 释放 <code>da</code> 起始的一页外存空间</li></ol><p>当我们需要换出一个内存中的物理页至外存时：</p><ol><li><p>从 <code>[0x3900000, 0x3910000)</code> 的内存空间中，选择一个物理页 <code>p</code></p></li><li><p>使用 <code>disk_alloc</code> 申请一页大小的外存空间，记该外存空间的起始地址为 <code>da</code></p></li><li><p>对指定页表中，所有 <code>PTE_V</code> 为 <code>1</code> 且高 20 位为 <code>p</code> 的物理页号的页表项，做如下操作：</p><p>​    i. 将 <code>PTE_V</code> 置 <code>0</code></p><p>​    ii. 将 <code>PTE_SWP</code> 置 <code>1</code></p><p>​    iii. 在高 20 位中填入 <code>da</code> 对应的外存页号</p><p>​    iv. 维持其它权限位不变</p><p>​    v. 无效化旧 TLB 表项</p></li><li><p>将物理页 <code>p</code> 上的内容拷贝到外存中 <code>da</code> 起始的一页空间上</p></li><li><p>释放物理页 <code>p</code>，也就是将其插回 <code>page_free_swapable_list</code> 链表中</p></li></ol><h4 id="任务总结"><a href="#任务总结" class="headerlink" title="任务总结"></a>任务总结</h4><p>在提交前，你需要完成以下任务：</p><ul><li>换入部分：<ul><li>完成 <code>is_swapped</code> 函数。</li><li>完成 <code>swap</code> 函数，维护 <code>page_free_swapable_list</code> 链表，适时无效化 TLB 中的旧表项。</li></ul></li><li>换出部分：<ul><li>完成 <code>swap_alloc</code> 函数，维护 <code>page_free_swapable_list</code> 链表，适时无效化 TLB 中的旧表项。</li></ul></li></ul><p>本题不涉及课下代码的修改。</p><h4 id="实验提供代码"><a href="#实验提供代码" class="headerlink" title="实验提供代码"></a>实验提供代码</h4><p>请将本部分提供代码附加在你的 <code>kern/pmap.c</code> 的尾部，然后开始做题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;swap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> <span class="title">page_free_swapable_list</span>;</span></span><br><span class="line"><span class="type">static</span> u_char *<span class="title function_">disk_alloc</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disk_free</span><span class="params">(u_char *pdisk)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap_init</span><span class="params">()</span> &#123;</span><br><span class="line">LIST_INIT(&amp;page_free_swapable_list);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = SWAP_PAGE_BASE; i &lt; SWAP_PAGE_END; i += BY2PG) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span> =</span> pa2page(i);</span><br><span class="line">LIST_REMOVE(pp, pp_link);</span><br><span class="line">LIST_INSERT_HEAD(&amp;page_free_swapable_list, pp, pp_link);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface for &#x27;Passive Swap Out&#x27;</span></span><br><span class="line"><span class="keyword">struct</span> Page *<span class="title function_">swap_alloc</span><span class="params">(Pde *pgdir, u_int asid)</span> &#123;</span><br><span class="line"><span class="comment">// Step 1: Ensure free page</span></span><br><span class="line"><span class="keyword">if</span> (LIST_EMPTY(&amp;page_free_swapable_list)) &#123;</span><br><span class="line"><span class="comment">/* Your Code Here (1/3) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Get a free page and clear it</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span> =</span> LIST_FIRST(&amp;page_free_swapable_list);</span><br><span class="line">LIST_REMOVE(pp, pp_link);</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span> *)page2kva(pp), <span class="number">0</span>, BY2PG);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interfaces for &#x27;Active Swap In&#x27;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_swapped</span><span class="params">(Pde *pgdir, u_long va)</span> &#123;</span><br><span class="line"><span class="comment">/* Your Code Here (2/3) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">swap</span><span class="params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;</span><br><span class="line"><span class="comment">/* Your Code Here (3/3) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pte <span class="title function_">swap_lookup</span><span class="params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;</span><br><span class="line"><span class="comment">// Step 1: If corresponding page is swapped out, swap it in</span></span><br><span class="line"><span class="keyword">if</span> (is_swapped(pgdir, va)) &#123;</span><br><span class="line">swap(pgdir, asid, va);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Look up page table element.</span></span><br><span class="line">Pte *ppte;</span><br><span class="line">page_lookup(pgdir, va, &amp;ppte);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: Return</span></span><br><span class="line"><span class="keyword">return</span> ppte == <span class="literal">NULL</span> ? <span class="number">0</span> : *ppte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disk Simulation (Do not modify)</span></span><br><span class="line">u_char swap_disk[SWAP_DISK_NPAGE * BY2PG] __attribute__((aligned(BY2PG)));</span><br><span class="line">u_char swap_disk_used[SWAP_DISK_NPAGE];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u_char *<span class="title function_">disk_alloc</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> alloc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;alloc &lt; SWAP_DISK_NPAGE &amp;&amp; swap_disk_used[alloc]; alloc++) &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">assert(alloc &lt; SWAP_DISK_NPAGE);</span><br><span class="line">swap_disk_used[alloc] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;swap_disk[alloc * BY2PG];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disk_free</span><span class="params">(u_char *pdisk)</span> &#123;</span><br><span class="line"><span class="type">int</span> offset = pdisk - swap_disk;</span><br><span class="line">assert(offset % BY2PG == <span class="number">0</span>);</span><br><span class="line">swap_disk_used[offset / BY2PG] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Page *<span class="title function_">swap_alloc</span><span class="params">(Pde *pgdir, u_int asid)</span> &#123;</span><br><span class="line"><span class="comment">// Step 1: Ensure free page</span></span><br><span class="line"><span class="keyword">if</span> (LIST_EMPTY(&amp;page_free_swapable_list)) &#123;</span><br><span class="line"><span class="comment">/* Your Code Here (1/3) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> pa2page(<span class="number">0x3900000</span>);</span><br><span class="line">u_long da = (u_long)disk_alloc();</span><br><span class="line"><span class="keyword">for</span> (u_long i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">Pde *pgdir_entryp = pgdir + i;</span><br><span class="line"><span class="keyword">if</span> (*pgdir_entryp &amp; PTE_V) &#123;</span><br><span class="line">Pte *tmp = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));</span><br><span class="line"><span class="keyword">for</span> (u_long j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">Pte *pte = tmp + j;</span><br><span class="line"><span class="keyword">if</span> ((*pte &amp; PTE_V) &amp;&amp; PTE_ADDR(*pte) == <span class="number">0x3900000</span>) &#123;</span><br><span class="line"><span class="comment">// 维持其他权限位保持不变</span></span><br><span class="line">*pte = PTE_ADDR(da) | (*pte &amp; <span class="number">0xfff</span>);</span><br><span class="line">*pte = (*pte &amp; ~PTE_V) | PTE_SWP; <span class="comment">// 注意优先级</span></span><br><span class="line">                        <span class="comment">// tlb_invalidate(asid, va);</span></span><br><span class="line">tlb_invalidate(asid, (i &lt;&lt; <span class="number">22</span>) + (j &lt;&lt; <span class="number">12</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)da, (<span class="type">void</span> *)page2kva(p), BY2PG);</span><br><span class="line">        <span class="comment">// 没有清空 Page P 是因为在下一次使用 p 的时候会初始化</span></span><br><span class="line">LIST_INSERT_HEAD(&amp;page_free_swapable_list, p, pp_link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Get a free page and clear it</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span> =</span> LIST_FIRST(&amp;page_free_swapable_list);</span><br><span class="line">LIST_REMOVE(pp, pp_link);</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span> *)page2kva(pp), <span class="number">0</span>, BY2PG);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interfaces for &#x27;Active Swap In&#x27;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_swapped</span><span class="params">(Pde *pgdir, u_long va)</span> &#123;</span><br><span class="line"><span class="comment">/* Your Code Here (2/3) */</span></span><br><span class="line">Pde *pgdir_entryp = pgdir + PDX(va);</span><br><span class="line"><span class="keyword">if</span> (!(*pgdir_entryp &amp; PTE_V)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Pte *pte = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp)) + PTX(va);</span><br><span class="line"><span class="keyword">if</span> ((*pte &amp; PTE_SWP) &amp;&amp; ~(*pte &amp; PTE_V)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">swap</span><span class="params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;</span><br><span class="line"><span class="comment">/* Your Code Here (3/3) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> swap_alloc(pgdir, asid);</span><br><span class="line"></span><br><span class="line">u_long da = PTE_ADDR(*((Pte *)KADDR(PTE_ADDR(*(pgdir + PDX(va)))) + PTX(va)));</span><br><span class="line">u_long kva = page2kva(p);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)kva, (<span class="type">void</span> *)da, BY2PG);</span><br><span class="line"><span class="keyword">for</span> (u_long i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                 Pde *pgdir_entryp = pgdir + i;</span><br><span class="line">                 <span class="keyword">if</span> (*pgdir_entryp &amp; PTE_V) &#123;</span><br><span class="line">                         Pte *tmp = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));</span><br><span class="line">                         <span class="keyword">for</span> (u_long j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">                                 Pte *pte = tmp + j;</span><br><span class="line">                                 <span class="keyword">if</span> (PTE_ADDR(*pte) == da &amp;&amp; (*pte &amp; PTE_SWP) &amp;&amp; ~(*pte &amp; PTE_V)) &#123;</span><br><span class="line"> *pte = PTE_ADDR(page2pa(p)) | (*pte &amp; <span class="number">0xfff</span>);</span><br><span class="line">*pte = (*pte &amp; ~PTE_SWP) | PTE_V ;</span><br><span class="line"> tlb_invalidate(asid, (i &lt;&lt; <span class="number">22</span>) + (j &lt;&lt; <span class="number">12</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">                         &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line">disk_free((u_char *)da);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>感觉自己目前主要是学习方法上的问题，比较依赖课上视频的讲解（视频内容比较详细，个人没有更多思考）。在 hint帮助下能完成实验，但是对实验的整体架构和一些原理还是比较模糊的概念，导致课上摸索着上机的感觉。给自己的建议是提早写课下（也就是在视频讲解出之前自己先写一遍课下，遇到问题动动脑子，多联系上下文）</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA OO hw5 &amp;&amp; hw6</title>
      <link href="/2023/04/01/OO-unit2-hw5&amp;hw6/"/>
      <url>/2023/04/01/OO-unit2-hw5&amp;hw6/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 本次作业的基本目标是模拟<strong>多线程实时电梯系统</strong>，熟悉线程的创建、运行等基本操作，熟悉多线程程序的设计方法，掌握线程安全知识并解决线程安全问题。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于第五次作业对电梯调度策略和电梯运行策略没有理解清楚，导致逻辑混乱，对电梯的状态更新复杂从而出现了bug，以及调度策略有问题导致时间性能较差。于是第六次作业进行了重构，采取了新的策略，目前评测机反馈正确性和性能都是可以的。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote><p>继承、接口、多态形成了面向<strong>数据和行为</strong>抽象的层次结构 （关注数据抽象和行为抽象）</p><p>线程、共享、交互形成了面向<strong>并发和协同</strong>抽象的层次结构 （关注并发行为的安全和效率）</p></blockquote><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><ol><li>修饰类：表明这个类不能被继承。</li><li>修饰方法：把方法锁定，以防任何继承类修改它的含义。</li><li>修饰变量：对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ol><h3 id="线程的互斥处理（monitor）——-synchronized"><a href="#线程的互斥处理（monitor）——-synchronized" class="headerlink" title="线程的互斥处理（monitor）—— synchronized"></a>线程的互斥处理（monitor）—— synchronized</h3><p>一个实例中的 synchronized 方法每次只能由一个线程运行，对非 synchronized 方法没有影响。</p><p>每个实例拥有独立的锁。</p><p>只在共享对象中设置同步块，仅使用同步块中的共享对象来守护该同步块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 代码块</span></span><br><span class="line"><span class="keyword">synchronized</span>(expr) &#123; <span class="comment">// expr 为获取锁的实例</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synchronized 实例方法和 synchronized 代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> method &#123; <span class="comment">// 使用this的锁来执行线程的互斥处理</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> method &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的协作-——-wait-notify-notifyAll"><a href="#线程的协作-——-wait-notify-notifyAll" class="headerlink" title="线程的协作 —— wait, notify, notifyAll"></a>线程的协作 —— wait, notify, notifyAll</h3><p>wait, notify, notifyAll 都是 java.lang.Object 类的方法。</p><p>每个实例都拥有一个等待队列，放置在执行实例的 wait 方法后停止操作的线程。</p><p>若要执行 wait, notify, notifyAll 操作，线程必须持有锁。如果线程进入等待队列，便会释放其实例的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj.wait(); <span class="comment">// 线程正在obj上等待</span></span><br><span class="line">wait; <span class="comment">// 线程正在this上等待</span></span><br><span class="line"><span class="built_in">this</span>.wait(); <span class="comment">// 线程正在this上等待</span></span><br><span class="line"></span><br><span class="line">obj.notifyAll(); <span class="comment">// 在obj实例的等待队列中休眠的所有线程都会被唤醒 </span></span><br><span class="line">notifyAll(); <span class="comment">// 在this实例的等待队列中休眠的所有线程都会被唤醒 </span></span><br><span class="line"><span class="built_in">this</span>.notifyAll(); <span class="comment">// 在this实例的等待队列中休眠的所有线程都会被唤醒 </span></span><br></pre></td></tr></table></figure><h3 id="Producer-Consumer-模式"><a href="#Producer-Consumer-模式" class="headerlink" title="Producer-Consumer 模式"></a><a href="https://blog.csdn.net/yangsf_/article/details/123760952?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8Bjava%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-123760952.142^v75^control,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm=1018.2226.3001.4187">Producer-Consumer 模式</a></h3><ul><li>Data：由 Producer 生成，供 Consumer 使用。</li><li>Producer： Producer 生成 Data，并将其传递给 Channel。</li><li>Consumer：从 Channel 获取 Data 并使用。</li><li>Channel：保管从 Producer 获取的 Data，并响应 Consumer 的请求，传递 Data。为了确保安全性，Channel 会对 Producer 和 Consumer 的访问执行互斥处理。</li></ul><p>一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buffer</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(buffer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(buffer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Buffer buffer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           buffer.push();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Buffer buffer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">haveGoods</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 生产者放入商品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (haveGoods) &#123; <span class="comment">// 已有货物，消费者取出商品</span></span><br><span class="line">            <span class="comment">// 生产者等待消费者消费</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!haveGoods)&#123; <span class="comment">// 被消费者通知生产</span></span><br><span class="line">            cnt ++;</span><br><span class="line">            System.out.println(<span class="string">&quot;Producer put:&quot;</span> + cnt);</span><br><span class="line">            haveGoods = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep((<span class="type">int</span>)(Math.random()*<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            <span class="comment">// 通知消费者消费</span></span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费者取出商品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!haveGoods) &#123; <span class="comment">// 没有货物，生产者生产商品</span></span><br><span class="line">            <span class="comment">// 消费者等待生产者生产</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (haveGoods) &#123; <span class="comment">// 被生产者通知消费</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer get:&quot;</span> + cnt);</span><br><span class="line">            haveGoods = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 通知生产者生产</span></span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>以上参考《图解 Java 多线程设计模式》。</em></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>模拟多线程实时电梯系统。系统从标准输入中输入请求信息，程序进行接收和处理，模拟电梯运行，将必要的运行信息通过输出接口进行输出。 具体而言，本次作业电梯系统具有的功能为：上下行，开关门，以及模拟乘客的进出，以及模拟电梯系统扩建和日常维护时乘客的调度。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>看完题目，我们先理清一些概念：</p><p><strong>电梯调度策略</strong>：把请求分配给电梯时采取的策略。</p><p><strong>电梯运行策略</strong>：电梯处理自己的请求队列采取的策略。</p><p>通过题目可以发现程序要干的事情无非是：① 获取输入的请求信息；② 处理请求信息：若请求为乘客，则将乘客分配给电梯；若请求为电梯扩建和维护，就更新电梯。③ 电梯接送乘客到指定楼层。</p><p>根据多线程设计模式并参考了第三次实验下发的模板代码，我们确定线程数及线程所做的工作为：</p><ol><li>输入线程。接收输入请求，若为乘客请求，就将其放入总乘客队列；若为电梯扩建和维护请求，就更新 vector\<elevator\> 。</li><li>调度线程。根据电梯调度策略，将总乘客请求分配给每部电梯的等待队列。</li><li>电梯线程。有多少部电梯就有多少个电梯线程，它们之间相互独立的处理各自的等待队列。</li></ol><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>类：</p><ul><li>MainClass：初始化实例和开启线程。</li><li>InputThread：获取输入的请求，若为乘客请求，就将其放入总乘客队列；若为电梯扩建和维护请求，就更新 vector\<elevator\> 。</li><li>WaitQueue：总乘客队列。</li><li>Schedule：根据电梯调度策略，将乘客请求分配给电梯的等待队列。</li><li>Elevator：记录电梯的状态，模拟电梯运行过程。</li><li>Strategy：得到电梯下一状态。</li><li>RequestQueue：电梯的等待队列。</li><li>Person：电梯的等待队列。</li><li>Counter：计数器，判断乘客请求是否都处理完，用于线程终止判断。</li></ul><p><img src="https://s2.loli.net/2023/04/02/g3nbYQPhyVjxSTm.png" alt="image-20230402020924870"></p><p><em>还没有画类图和时序图啦~ 不如先看看idea自动生成的叭~</em></p><h2 id="线程设计"><a href="#线程设计" class="headerlink" title="线程设计"></a>线程设计</h2><p>在上文分析中，我们已经确定了线程的种类及其个数，在此回顾一下：</p><ul><li>主线程进行初始化和启动其他线程。</li><li>输入线程获取输入的请求。若请求为 PersonRequest ，就用 addRequest 方法将其放入 WaitQueue 总队列；若请求为 ElevatorRequest，就用 expandElevator 方法将新增电梯放入 ElevatorQueue 电梯队列；瑞请求为 MaintainRequest，就用 maintainElevator 方法维护电梯。</li><li>调度线程将请求分配给电梯。调度线程从 WaitQueue 中用 getRequest 获取请求，遍历 ElevatorQueue 将请求发给加入该请求后模拟花费时间最少的电梯的 RequestQueue。</li><li>电梯线程处理 RequestQueue，模拟电梯上行、下行、开关门等行为。其利用 Strategy 获得电梯下一状态，从 RequestQueue 中获取 canPutOn 的请求。</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全（thread-safe）是关于对象对象是否能被多个线程安全访问的特性。如果一个对象是线程安全的，则无论多个线程以什么样的交叠次序来访问都不会影响该对象的行为结果。</p><p>如何会导致线程不安全：</p><ul><li>读写冲突<ul><li>check-then-act</li><li>read-modify-write</li></ul></li><li>写写冲突（覆盖）</li></ul><p>线程安全的设计考虑：</p><ul><li>使用不可变对象</li><li>使用可变对象<ul><li>操作的原子性</li><li>共享对象要始终处于严密控制之下</li><li>设置范围适当的临界区（临界区最小化）</li><li>使用合适的监控器</li></ul></li></ul><p>在我的程序中主要通过 synchronized 语句块完成线程互斥。</p><p>此外，对象共享是产生线程安全问题的根本原因。在思考某一部分代码是否会产生线程安全问题时，可以思考其是否会被多个线程访问，线程访问的读写关系等。</p><h3 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h3><p>当某个线程卡在临界区或一直获取不到资源时，会发生轮询，会比较耗费CPU。当你提交时如果遇到 CTLE 可以考虑代码中是否有轮询。比如说当 Schedule 想要获取乘客请求时，waitQueue 为空，此时我们可以让该线程进入 waitQueue 的等待队列，也就是让它 wait 一下。当 waitQueue 非空（即输入线程把乘客请求给了 waitQueue）时，唤醒 waitQueue 的等待队列 （notifyAll）。该部分可以参考前文提到的 Producer-Consumer 模式或 Guard Suspension 模式。</p><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>线程应该在什么时候终止是一个必须要解决的问题，否则线程一直无法终止会引发 RTLE 问题。这一部分内容有学长推荐看《图解Java多线程设计模式》中的 <strong>Two Phase Termination</strong> 这一章。我主要是通过实验代码理解。当输入结束，所有乘客请求都处理完成，那么程序就结束了。在介绍每个线程的结束条件之前，我们先来看看线程是如何结束的。run 方式是线程的入口，也是线程结束的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (线程结束条件) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> someting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入线程：由官方文档可知，当读入的 request == null 时说明输入结束，此时传递给 waitQueue end标志位，并结束输入线程。</li><li>调度线程：在hw5中当输入线程结束并且总队列为空时即可结束调度线程。但是在 hw6 中电梯维护时会把请求还给总队列，前面的条件会触发bug。所以在hw6中我将结束条件改为输入线程结束并且总队列为空并且所有请求已处理完毕（用counter静态类记录请求的出入），此时传递给 RequestQueue end标志位。</li><li>电梯线程：当 requestQueue end标志位为 true 时结束线程。</li></ul><p>具体实现可以参考实验代码。 </p><h3 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h3><ul><li>利用调试功能。可以根据输出大致判断出bug触发地，据此选定断点。比如说电梯门开了之后乘客却没有进来，此时就将断点设置在开门的方法。</li><li>利用 printf 输出。可以输出电梯状态改变、请求状态改变（进入等待队列等信息）、线程状态改变以及观察时间戳等判断。</li><li>有同学跟我分享了一种方法：设置一个 Debug 类，通过 stderr 抛出异常，这样也不会影响输出检测。</li></ul><h2 id="电梯调度策略"><a href="#电梯调度策略" class="headerlink" title="电梯调度策略"></a>电梯调度策略</h2><p>电梯调度有很多策略：(1) 模拟电梯保证局部最优解的策略，在输入线程获得一个请求时，深克隆电梯类进行模拟从而将请求分配各所花费时间最少的电梯。(2) 较为均衡的分配方式（第 i 位乘客分配给第 (i % 6) 座电梯），当输入请求数量较多的时候，性能上也还不错。(3) 随机分配方式 random，其实和前者策略差不多。(4) 自由竞争策略，所有电梯共用输入线程的请求队列，当输入一个请求时，所有电梯都努力去获取这个请求，这种策略在时间性能上占据优势，但是电量消耗会比较高。</p><p>我在 hw6 中实现了电梯模拟策略，也就是往届所说的 影子电梯。其主要思想为：对于每一个待分配的请求，“涉克隆”电梯此时的状态，将请求放入电梯的等待队列，进行模拟（将上下行开门的 <code>sleep(400)</code> 改为 <code>time += 400</code>），选择最早结束的电梯接收这个请求。和周围同学比较发现这种策略在运行时间和耗电量都比较优。</p><h2 id="电梯运行策略"><a href="#电梯运行策略" class="headerlink" title="电梯运行策略"></a>电梯运行策略</h2><p>我采用了 <strong>look</strong> 算法：当电梯在往上走时，如果遇到向上的请求就捎带上，当<strong>电梯内没有乘客并且电梯前方没有等待的请求</strong>时就换方向。当到达某一楼层时，如果电梯未满并且请求与电梯运行方向一致时，就开门捎带上请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">nextState</span> <span class="operator">=</span> strategy.getStrategy(floor, direction, fullNum, curInRequests, requestQueue); <span class="comment">// strategy 获取电梯下一状态</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEnd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">switch</span> (nextState) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;open&quot;</span>:</span><br><span class="line">        openAndClose();</span><br><span class="line">        preTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;keep&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> (direction) &#123; up(); &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; down(); &#125;</span><br><span class="line">        preTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;reverse&quot;</span>:</span><br><span class="line">        direction = !direction;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;wait&quot;</span>:</span><br><span class="line">        direction = <span class="literal">true</span>;</span><br><span class="line">        requestQueue.waitRequest();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">        isEnd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li><p>往届学长提出了“量子电梯”的概念：</p><p>当电梯在等待时，电梯的请求队列获得了请求，电梯开始运动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[time1] ARRIVE floor1</span><br><span class="line">[time2] begin wait</span><br><span class="line">[time3] end wait</span><br><span class="line">[time4] ARRIVE floor2</span><br></pre></td></tr></table></figure><p>按照一般同学们的处理，有 $time4 = time3 + 0.4$ 。</p><p>然而我们可以利用 wait 的时间，因为我们仅需保证 <code>time4 - time1 &gt; 0.4</code> 。</p><p>具体实现就是记录电梯最后一次关门、上下行的时间，然后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (currentTime - preTime &lt; speed) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(speed - currentTime + preTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    floor++;</span><br><span class="line">    TimableOutput.println(String.format(<span class="string">&quot;ARRIVE-%d-%d&quot;</span>, floor, id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当电梯收到维护请求的时候，需要将电梯还未送达的乘客请求返回给 waitQueue，为了尽量缩短乘客的等待时间，将请求返回到 waitQueue 的队首使他们有限被分配。</p></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>​    真的好喜欢自己重构后的代码，感觉对线程安全和电梯策略处理的都挺清晰的，在 Toby 的性能测试平台上每个店都能达到99.9以上。希望能安全度过 hw6 的强测和互测啦~</p><p><em>这是2023年4月10日的更新，主要内容为迭代 homework 7。</em></p><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>接上文，hw6的强测和互测没有问题，主要是在强测中有一个点的性能不太好。这个点主要考虑为该情况下的优化：当有很多从同楼层出发前往各不同楼层的请求时（以该数据为例，为了简化我们假设仅有一部电梯），若不做特殊处理，仅按请求进入顺序调度，那么电梯需要从1-11-1接送前6名乘客，再从1-11-1接送第7名乘客。而如果我们<strong>按请求出发和到达楼层差的绝对值排序</strong>，显然电梯运行的层数会显著减少。<em>所以或许写OO有时间的话，除了评测机，还可以集思广益一些特殊数据捏。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1-FROM-11-TO-1</span><br><span class="line">2-FROM-11-TO-9</span><br><span class="line">3-FROM-11-TO-3</span><br><span class="line">4-FROM-11-TO-7</span><br><span class="line">5-FROM-11-TO-7</span><br><span class="line">6-FROM-11-TO-8</span><br><span class="line">7-FROM-11-TO-1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Object Oriented </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA OO第一单元——递归下降处理表达式</title>
      <link href="/2023/02/28/OO-unit1/"/>
      <url>/2023/02/28/OO-unit1/</url>
      
        <content type="html"><![CDATA[<h1 id="北航OO第一单元作业总结"><a href="#北航OO第一单元作业总结" class="headerlink" title="北航OO第一单元作业总结"></a>北航OO第一单元作业总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>通过对表达式结构进行建模，完成多变量多项式的括号展开，初步体会层次化设计的思想。</p></blockquote><p>然而我对自己的设计并不是很满意，当完成第三次作业的时候代码行数已经达到了993行。还有许多可以改进之处，在此进行总结。</p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><h3 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h3><blockquote><p>读入一个包含加、减、乘、乘方以及括号（其中括号的深度<strong>至多为 1 层</strong>）的<strong>多变量</strong>表达式，输出<strong>恒等变形展开所有括号后</strong>的表达式。</p></blockquote><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>我采用的是<strong>递归下降算法</strong>，先将表达式进行语法解析，再计算化简。根据课程提供的形式化表述，表达式解析为：</p><ul><li>Expr：表达式及表达式因子</li><li>Term：项</li><li>ExprPow：表达式及对于指数</li><li>Number：常数因子</li><li>Power：变量因子</li></ul><p>具体的类图如下：</p><p><img src="https://s2.loli.net/2023/03/18/aAwBK9H1xLWIjgO.png" alt="image-20230317163205842"></p><h4 id="架构解析"><a href="#架构解析" class="headerlink" title="架构解析"></a>架构解析</h4><p>本次作业可以分为三个部分，第一个是表达式模型，第二个是表达式解析，第三个是表达式化简。</p><h5 id="表达式模型"><a href="#表达式模型" class="headerlink" title="表达式模型"></a>表达式模型</h5><p>根据题目提供的形式化表述(摘录部分)：</p><blockquote><p>表达式 → 空白项 [加减 空白项] 项 空白项 | 表达式 加减 空白项 项 空白项</p><p>项 → [加减 空白项] 因子 | 项 空白项 ‘*’ 空白项 因子</p><p>因子 → 变量因子 | 常数因子 | 表达式因子</p><p>变量因子 → 幂函数</p><p>常数因子 → 带符号的整数</p><p>表达式因子 → ‘(‘ 表达式 ‘)’ [空白项 指数]</p><p>幂函数 → (‘x’ | ‘y’ | ‘z’) [空白项 指数]</p></blockquote><p>表达式由项组成（用 <code>Arraylist</code> 存储项，加减合并到项中）；项由三类因子组成，这里使用了 <code>Factor</code> 接口，首个因子前的加减作为一个因子存入项中；变量因子、常熟因子、表达式因子分别为 <code>Power</code> ，<code>Number</code>， <code>Expr</code>类中。</p><h5 id="表达式解析"><a href="#表达式解析" class="headerlink" title="表达式解析"></a>表达式解析</h5><p>语法分析主要参考了OO课程组发布的预习文章中的递归下降算法的代码。<code>Lexer</code>类实现词法分析，实现加减、变量、数字等基本单元的提取。<code>Parser</code> 类对表达式进行语法分析，主要采用递归调用的方法。</p><h5 id="表达式化简"><a href="#表达式化简" class="headerlink" title="表达式化简"></a>表达式化简</h5><p>由于不存在嵌套括号，表达式即为 $A+B+…+Z$ （其中A, B, …, Z为项）的形式，可以先将项进行乘法展开，再进行加法。另外注意到化简完的式子均形如 A*x**B*y**C*z**D  (A, B, C, D 均为常数)，在进行乘法化简的时候只需要统计项中 A, B, C, D的值，在进行加法化简的时候可以考虑使用 <code>HashMap&lt;key, value&gt;</code>, <code>key</code>应为 $x$, $y$, $z$的指数的键值对，可应用 <code>key=(String)(B|C|D)</code> （这样可以避免重写 <code>HashMap</code> 的 <code>equals</code> 和 <code>hashcode</code> 方法）。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p>如何处理空白字符及符号问题？</p><p>对于空白字符，由于本次作业不需要我们判断输入的合法性，所以对于输入的字符串 <code>input</code> ，直接过滤掉所有空白字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input = input.replaceAll(<span class="string">&quot;[ \t]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>对于符号，我们注意到：①<strong>常数因子</strong>带符号；②在<strong>项</strong>的第一个因子前可以带一个正负号；③在<strong>表达式</strong>的第一项之前可以带一个正负号；④表达式中项与项之间的加减号。    在出现符号的相应位置，如果是 <code>-</code>，就转化为项中的一个 $-1$ 的常数因子，例如 -x=-1*x ；如果是 <code>+</code>，忽略即可。同时我们也可以预处理连续的 <code>+-</code> 和 <code>*+</code> 等情况进行优化。</p></li><li><p>如何处理 <em>表达式因子 → ‘(‘ 表达式 ‘)’ [空白项 指数]</em> ？</p><p>我在 Training 给的模板的基础上新增了 <code>ExprPow</code> 类。在语法分析时，当项中读到了 <code>ExprPow</code> 类的因子，就把其展开为 Expr*Expr*…*Expr 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExprPow</span> <span class="keyword">implements</span> <span class="title class_">Factor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expr baseExpr;</span><br><span class="line">    <span class="keyword">private</span> Integer exponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意细节</p><p>例如，$0**0=1$ ，其中，前者的 0 可以为满足题意的任意表达式因子化简后的结果。</p></li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>对比最冗余的输出，除了在上文表达式化简中提及的同类项合并外，可以考虑优化项为0，项的系数为1，变量的指数为0或1等的情形，以下主要说明相对不易考虑到的两点：</p><ol><li>由于表达式第一项的正负号可以省略，我们应尽量保证其为正的，此时我们可以考虑如果该项为负，就放到生成的字符串结果的末尾，如果为正，就放到生成的字符串结果的开头。然后判断字符串首字母是否为 <code>+</code>。</li><li><code>x*x</code> 比 <code>x**2</code> 更优。</li></ol><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><div class="table-container"><table><thead><tr><th>Expr.addSimplify()</th><th>15.0</th><th>1.0</th><th>6.0</th><th>6.0</th></tr></thead><tbody><tr><td>Expr.addTerm(Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.getTerms()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.printExpr(HashMap)</td><td>38.0</td><td>4.0</td><td>15.0</td><td>17.0</td></tr><tr><td>Expr.printXyz(char, BigInteger, int)</td><td>15.0</td><td>1.0</td><td>9.0</td><td>9.0</td></tr><tr><td>ExprPow.ExprPow(Expr, Integer)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprPow.getBaseExpr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprPow.getExponent()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.next()</td><td>7.0</td><td>2.0</td><td>5.0</td><td>6.0</td></tr><tr><td>Lexer.peek()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>MainClass.main(String[])</td><td>18.0</td><td>3.0</td><td>11.0</td><td>12.0</td></tr><tr><td>Number.getNum()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Number.Number(BigInteger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parse.exprFactor()</td><td>5.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Parse.numberFactor()</td><td>11.0</td><td>1.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Parse.Parse(Lexer)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parse.parseExpr()</td><td>7.0</td><td>1.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Parse.parseFactor()</td><td>4.0</td><td>1.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Parse.parseTerm()</td><td>11.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Parse.powerFactor()</td><td>24.0</td><td>9.0</td><td>6.0</td><td>9.0</td></tr><tr><td>Power.add(int, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.getXx()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.getYy()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.getZz()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.Power(int, int, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.addFactor(Factor)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.addTerm(Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.getFactors()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.multiply()</td><td>34.0</td><td>1.0</td><td>11.0</td><td>11.0</td></tr><tr><td>Term.multsimplify(Term)</td><td>4.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>195.0</td><td>50.0</td><td>118.0</td><td>125.0</td></tr><tr><td>Average</td><td>5.735294117647059</td><td>1.4705882352941178</td><td>3.4705882352941178</td><td>3.676470588235294</td></tr></tbody></table></div><p>由于输出字符串全都集中在了<code>Expr</code> 类的 <code>printExpr</code> 方法中，复杂度较高；由于 <code>power</code> 类中存储的是 x, y, z 的次数，导致 <code>Parse</code> 类的 <code>PowerFactor</code>方法复杂度较高；在乘法计算时，由于一开始写的是先完全进行乘法展开再合并同类项，发现容易爆栈，于是直接在此基础上进行了修改，复杂度也比较高。</p><h3 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h3><p>本次作业遇到的bug主要是先完全进行乘法展开再合并同类项，发现容易爆栈，于是改成了在处理项的过程中就插入同类项合并操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然本次作业强测满分，互测没有被 hack，但整体的架构还是不太满意的，比如不支持括号嵌套，对 <code>power</code>的处理比较复杂，字符串输出难以迭代。这些都在后面的作业中有修改。</p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><h3 id="题目简述-1"><a href="#题目简述-1" class="headerlink" title="题目简述"></a>题目简述</h3><blockquote><p>读入<strong>一系列自定义函数的定义</strong>以及一个包含幂函数、三角函数、自定义函数调用的<strong>表达式</strong>，输出<strong>恒等变形展开所有括号后</strong>的表达式。</p></blockquote><h3 id="整体架构-1"><a href="#整体架构-1" class="headerlink" title="整体架构"></a>整体架构</h3><p>本次我才用了 <strong>边分析边化简</strong> 的方法，比起第一次作业采用的先分析后化简明显是有利的。</p><h4 id="迭代内容"><a href="#迭代内容" class="headerlink" title="迭代内容"></a>迭代内容</h4><p>对于表达式解析，新增了 <code>Trigon</code> 类存储三角函数（然而我的 <code>Expr</code> , <code>ExprPow</code>, <code>Trigon</code> 类是可以合并的）。</p><p>新增了 <code>CusFuncProcess</code> 和 <code>CusFunction</code> 来处理自定义函数因子。</p><p>重载 <code>equals</code> 方法判断表达式是否相等，重载 <code>toString</code> 方法返回字符串。</p><p><strong>具体的类图如下：</strong></p><p><img src="https://s2.loli.net/2023/03/18/1OacMNhywF6eZCH.png" alt="image-20230318103340317"></p><p>对于新增的类和方法：</p><ul><li>Trigon：三角函数因子</li><li>CusFunction：自变量函数</li><li>CusFuncProcess：自变量函数集合</li></ul><h3 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h3><p>在第一次作业的基础上迭代，主要考虑以下问题：</p><ol><li><p>括号嵌套处理</p><p>修改了计算化简部分的方法，处理上应该不会有太大问题。</p></li><li><p>三角函数处理</p><p>在语法分析时，三角函数因子的处理方式和其他因子相似。</p><p>在计算化简时，由于其独特的属性会带来一些不同，会在“性能优化”部分详细描述。</p></li><li><p>自定义函数调用</p><p>考虑到方法撰写的难度和时间、空间上的消耗，对于读入的自定义函数，先进行预处理：①对自定义函数用语法树分析一遍，再转为字符串；②将自定义函数中的形参按顺序用例如 <code>u</code> , <code>v</code> , <code>w</code> 等未出现的字母 <code>replaceAll</code> （原因请读者自己思考）。</p><p>当在所求的表达式中遇到自定义函数，将实参代入后再分析即可。这里值得注意的一点是<strong>在所求表达式中遇到形如</strong> $f(A, B, C)$ <strong>，如何取出实参</strong>？有多种做法，我采用的是用 <code>Parser</code> 取出实参 <code>exprA</code> , <code>exprB</code> , <code>exprC</code> ，再转化为字符串，代入自定义函数字符串。那么此时我们又会遇到一个问题：若 </p><script type="math/tex; mode=display">1</script><script type="math/tex; mode=display">f(x)=x*sin(x)</script><script type="math/tex; mode=display">f(y+sin(x))</script><p>如果按上述方法，我们会得到 $y+sin(x)/<em>/</em>2$ ，显然是有问题的。此时我们可以采用 <code>&quot;(&quot; + expr.toString() + &quot;)&quot;</code> 代入自定义函数字符串。 </p></li></ol><h3 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h3><p>我们注意到最终表达式的每一项形如 A*x**B*y**C*z**D*[sin(expr)**E][cos(expr)**F]$ ( $[]$ 表示这一项可以省略)。</p><ul><li>在 <code>multSimplify</code> 中，把每一项都化简成上述形式，其中三角函数的合并同类项需要判断 <code>expr</code> 是否相等（重载equals），如果相等指数相加（新开一个 <code>Trigon</code> 保存！！！）。</li><li>在 <code>addSimplify</code> 中，判断项与项是否相同（此处相同指除了系数 $A$ 外均相同），相同则 $A=A_1+A_2$ ， 其余不变。</li><li>$sin(0)=0, cos(0)=1$</li><li>$sin(-A)=-A, cos(-A)=A$</li><li>三角函数<strong>对应的嵌套因子</strong>为<strong>不带指数的表达式因子</strong>时，该表达式因子两侧必要的一层括号；否则可省略。</li><li>表达式尽量保证首项是正的。</li></ul><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><div class="table-container"><table><thead><tr><th>CusFuncProcess.CusFuncProcess(ArrayList)</th><th>3.0</th><th>1.0</th><th>3.0</th><th>3.0</th></tr></thead><tbody><tr><td>CusFuncProcess.getExpr(char, ArrayList, CusFuncProcess)</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>CusFunction.CusFunction(String)</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>CusFunction.getExprString(ArrayList)</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>CusFunction.getFuncName()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.add()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.addExpr(Expr)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.addSimply()</td><td>8.0</td><td>1.0</td><td>5.0</td><td>5.0</td></tr><tr><td>Expr.addTerm(Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.changeNegative()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.equals(Object)</td><td>16.0</td><td>6.0</td><td>5.0</td><td>8.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.getTerms()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.isNegative()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Expr.isPower()</td><td>19.0</td><td>7.0</td><td>6.0</td><td>11.0</td></tr><tr><td>Expr.toString()</td><td>8.0</td><td>1.0</td><td>7.0</td><td>7.0</td></tr><tr><td>ExprPow.ExprPow(Expr, Integer)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprPow.getBaseExpr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprPow.getExponent()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Lexer.getPos()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.next()</td><td>11.0</td><td>2.0</td><td>9.0</td><td>10.0</td></tr><tr><td>Lexer.peek()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>MainClass.initString(String)</td><td>18.0</td><td>3.0</td><td>11.0</td><td>12.0</td></tr><tr><td>MainClass.main(String[])</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Number.addNum(BigInteger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Number.equals(Object)</td><td>5.0</td><td>4.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Number.getNum()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Number.Number(BigInteger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Number.setNum(BigInteger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parse.cusfunctionFactor()</td><td>6.0</td><td>3.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Parse.exprFactor()</td><td>5.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Parse.numberFactor()</td><td>11.0</td><td>1.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Parse.Parse(Lexer)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parse.parseExpr()</td><td>7.0</td><td>1.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Parse.parseFactor()</td><td>8.0</td><td>1.0</td><td>10.0</td><td>10.0</td></tr><tr><td>Parse.parseTerm()</td><td>11.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Parse.powerFactor()</td><td>24.0</td><td>9.0</td><td>6.0</td><td>9.0</td></tr><tr><td>Parse.setCusFuncProcess(ArrayList)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parse.setCusFuncProcess(CusFuncProcess)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parse.trigonFactor()</td><td>19.0</td><td>7.0</td><td>7.0</td><td>9.0</td></tr><tr><td>Power.equals(Object)</td><td>6.0</td><td>4.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Power.getExponent()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.getType()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.Power(int, int)</td><td>3.0</td><td>1.0</td><td>1.0</td><td>3.0</td></tr><tr><td>Power.toString()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.addFactor(Factor)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.addTerm(Term)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.canAddsimply(Term)</td><td>14.0</td><td>7.0</td><td>3.0</td><td>8.0</td></tr><tr><td>Term.equals(Object)</td><td>16.0</td><td>6.0</td><td>5.0</td><td>8.0</td></tr><tr><td>Term.getFactors()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.multiply()</td><td>30.0</td><td>1.0</td><td>10.0</td><td>10.0</td></tr><tr><td>Term.multSimply()</td><td>22.0</td><td>1.0</td><td>11.0</td><td>11.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.toString()</td><td>40.0</td><td>6.0</td><td>15.0</td><td>17.0</td></tr><tr><td>Trigon.addExponent(int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Trigon.clonee()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Trigon.equals(Object)</td><td>6.0</td><td>4.0</td><td>5.0</td><td>6.0</td></tr><tr><td>Trigon.getExponent()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Trigon.getExprFactor()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Trigon.getisSin()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Trigon.toString()</td><td>8.0</td><td>1.0</td><td>5.0</td><td>8.0</td></tr><tr><td>Trigon.Trigon(Expr, boolean, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>342.0</td><td>123.0</td><td>212.0</td><td>247.0</td></tr><tr><td>Average</td><td>5.34375</td><td>1.921875</td><td>3.3125</td><td>3.859375</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>ExprPow</th><th>1.0</th><th>1.0</th><th>3.0</th></tr></thead><tbody><tr><td>Number</td><td>1.6</td><td>4.0</td><td>8.0</td></tr><tr><td>Trigon</td><td>2.25</td><td>8.0</td><td>18.0</td></tr><tr><td>CusFunction</td><td>2.3333333333333335</td><td>3.0</td><td>7.0</td></tr><tr><td>Lexer</td><td>2.4</td><td>7.0</td><td>12.0</td></tr><tr><td>Power</td><td>2.4</td><td>4.0</td><td>12.0</td></tr><tr><td>CusFuncProcess</td><td>3.0</td><td>3.0</td><td>6.0</td></tr><tr><td>Expr</td><td>3.6363636363636362</td><td>10.0</td><td>40.0</td></tr><tr><td>Parse</td><td>4.636363636363637</td><td>9.0</td><td>51.0</td></tr><tr><td>MainClass</td><td>6.0</td><td>10.0</td><td>12.0</td></tr><tr><td>Term</td><td>6.222222222222222</td><td>16.0</td><td>56.0</td></tr><tr><td>Total</td><td></td><td></td><td>225.0</td></tr><tr><td>Average</td><td>3.515625</td><td>6.818181818181818</td><td>20.454545454545453</td></tr></tbody></table></div><p>由于先完成作业基本要求，再思考性能优化，以及 <code>ArrayList</code> 的局限性，优化函数写的比较冗余；Expr，Term等类聚集了比较多的功能。</p><h3 id="bug-分析-1"><a href="#bug-分析-1" class="headerlink" title="bug 分析"></a>bug 分析</h3><p>在评测时，遇到一个bug是因为在合并同类项时没有进行深拷贝，直接在原项上加减，导致对该项出现在的其他位置产生了影响。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>对于第二次作业，我在第一次作业的基础上进行了大幅度的修改，仅保留了第一次作业的语法分析。并且感觉本次作业写的比较冗余，可能不利于第三次迭代。个人建议是在写之前，列清楚每个类、属性、方法的用处，调用关系等，而不是边写边扩充（其实我的代码里有些都是可以合并的）。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><h3 id="题目简述-2"><a href="#题目简述-2" class="headerlink" title="题目简述"></a>题目简述</h3><blockquote><p>读入<strong>一系列自定义函数的定义</strong>以及一个包含幂函数、三角函数、自定义函数调用、求导算子的<strong>表达式</strong>，输出<strong>恒等变形展开所有括号后</strong>的表达式。</p></blockquote><h3 id="整体架构-2"><a href="#整体架构-2" class="headerlink" title="整体架构"></a>整体架构</h3><h4 id="迭代内容-1"><a href="#迭代内容-1" class="headerlink" title="迭代内容"></a>迭代内容</h4><ul><li>加入<strong>求导算子</strong>，解决方法是在每个表达式模型的类中加入 <code>differentiate</code> 方法。</li><li>自定义函数表达式<strong>支持调用其他已已定义的函数</strong>，由于在第二次作业中我对自定义函数的处理是先对其语法分析，将结果存为字符串，再传给表达式语法分析的 <code>Parse</code> 类，进行自变量替换，已经支持该功能，几乎不需要做改动。</li></ul><p><strong>具体的类图如下：</strong></p><p><img src="https://s2.loli.net/2023/03/18/VNbO7CdU2ac1ZxG.png" alt="image-20230318105523253"></p><p>与第二次作业对比，仅在 <code>Expr</code>, <code>Term</code>, <code>Trigon</code> 类里加了求导方法。</p><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><div class="table-container"><table><thead><tr><th>CusFuncProcess.addCusFuncProcess(String)</th><th>0.0</th><th>1.0</th><th>1.0</th><th>1.0</th></tr></thead><tbody><tr><td>CusFuncProcess.getExpr(char, ArrayList, CusFuncProcess)</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>CusFunction.CusFunction(String, CusFuncProcess)</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>CusFunction.getExprString(ArrayList)</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>CusFunction.getFuncName()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.add()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.addAllTerms(Expr)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.addSimplify()</td><td>12.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Expr.addTerm(Term)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.changeNegative()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.clone()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Expr.differentiate(String)</td><td>4.0</td><td>2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Expr.diffIsZero(String)</td><td>1.0</td><td>2.0</td><td>1.0</td><td>2.0</td></tr><tr><td>Expr.equals(Object)</td><td>16.0</td><td>6.0</td><td>5.0</td><td>8.0</td></tr><tr><td>Expr.Expr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.getTerms()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Expr.isNegative()</td><td>3.0</td><td>3.0</td><td>2.0</td><td>3.0</td></tr><tr><td>Expr.isPower()</td><td>16.0</td><td>7.0</td><td>6.0</td><td>11.0</td></tr><tr><td>Expr.toString()</td><td>8.0</td><td>1.0</td><td>7.0</td><td>7.0</td></tr><tr><td>ExprPow.clone()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprPow.ExprPow(Expr, Integer)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprPow.getBaseExpr()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>ExprPow.getExponent()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.getNumber()</td><td>2.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Lexer.getPos()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.Lexer(String)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Lexer.next()</td><td>11.0</td><td>2.0</td><td>9.0</td><td>10.0</td></tr><tr><td>Lexer.peek()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>MainClass.initString(String)</td><td>18.0</td><td>3.0</td><td>11.0</td><td>12.0</td></tr><tr><td>MainClass.main(String[])</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Number.addNum(BigInteger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Number.clone()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Number.equals(Object)</td><td>5.0</td><td>4.0</td><td>3.0</td><td>4.0</td></tr><tr><td>Number.getNum()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Number.Number(BigInteger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Number.setNum(BigInteger)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parse.cusfunctionFactor()</td><td>6.0</td><td>3.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Parse.derivativeFactor()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Parse.exprFactor()</td><td>5.0</td><td>3.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Parse.numberFactor()</td><td>11.0</td><td>1.0</td><td>8.0</td><td>8.0</td></tr><tr><td>Parse.Parse(Lexer)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parse.parseExpr()</td><td>7.0</td><td>1.0</td><td>7.0</td><td>7.0</td></tr><tr><td>Parse.parseFactor()</td><td>9.0</td><td>1.0</td><td>11.0</td><td>11.0</td></tr><tr><td>Parse.parseTerm()</td><td>11.0</td><td>1.0</td><td>6.0</td><td>6.0</td></tr><tr><td>Parse.powerFactor()</td><td>24.0</td><td>9.0</td><td>6.0</td><td>9.0</td></tr><tr><td>Parse.setCusFuncProcess(CusFuncProcess)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Parse.trigonFactor()</td><td>19.0</td><td>7.0</td><td>7.0</td><td>9.0</td></tr><tr><td>Power.clone()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.equals(Object)</td><td>6.0</td><td>4.0</td><td>4.0</td><td>5.0</td></tr><tr><td>Power.getExponent()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.getType()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.Power(String, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Power.toString()</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Term.addAllFactors(Term)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.addFactor(Factor)</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.canAddSimplify(Term)</td><td>14.0</td><td>7.0</td><td>3.0</td><td>8.0</td></tr><tr><td>Term.clone()</td><td>1.0</td><td>1.0</td><td>2.0</td><td>2.0</td></tr><tr><td>Term.differentiate(String)</td><td>30.0</td><td>11.0</td><td>9.0</td><td>14.0</td></tr><tr><td>Term.equals(Object)</td><td>16.0</td><td>6.0</td><td>5.0</td><td>8.0</td></tr><tr><td>Term.getFactors()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.multiply()</td><td>34.0</td><td>1.0</td><td>11.0</td><td>11.0</td></tr><tr><td>Term.multSimplify()</td><td>23.0</td><td>2.0</td><td>11.0</td><td>12.0</td></tr><tr><td>Term.Term()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Term.toString()</td><td>40.0</td><td>6.0</td><td>14.0</td><td>16.0</td></tr><tr><td>Trigon.clone()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Trigon.differentiate(String)</td><td>3.0</td><td>1.0</td><td>3.0</td><td>3.0</td></tr><tr><td>Trigon.equals(Object)</td><td>6.0</td><td>4.0</td><td>5.0</td><td>6.0</td></tr><tr><td>Trigon.getExponent()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Trigon.getExprFactor()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Trigon.getisSin()</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Trigon.toString()</td><td>8.0</td><td>1.0</td><td>5.0</td><td>8.0</td></tr><tr><td>Trigon.Trigon(Expr, boolean, int)</td><td>0.0</td><td>1.0</td><td>1.0</td><td>1.0</td></tr><tr><td>Total</td><td>388.0</td><td>144.0</td><td>239.0</td><td>280.0</td></tr><tr><td>Average</td><td>5.388888888888889</td><td>2.0</td><td>3.3194444444444446</td><td>3.888888888888889</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>ExprPow</th><th>1.0</th><th>1.0</th><th>4.0</th></tr></thead><tbody><tr><td>Number</td><td>1.5</td><td>4.0</td><td>9.0</td></tr><tr><td>Power</td><td>1.8333333333333333</td><td>4.0</td><td>11.0</td></tr><tr><td>CusFuncProcess</td><td>2.0</td><td>3.0</td><td>4.0</td></tr><tr><td>CusFunction</td><td>2.3333333333333335</td><td>3.0</td><td>7.0</td></tr><tr><td>Lexer</td><td>2.4</td><td>7.0</td><td>12.0</td></tr><tr><td>Trigon</td><td>2.5</td><td>8.0</td><td>20.0</td></tr><tr><td>Expr</td><td>3.642857142857143</td><td>10.0</td><td>51.0</td></tr><tr><td>Parse</td><td>4.818181818181818</td><td>9.0</td><td>53.0</td></tr><tr><td>MainClass</td><td>6.0</td><td>10.0</td><td>12.0</td></tr><tr><td>Term</td><td>6.818181818181818</td><td>15.0</td><td>75.0</td></tr><tr><td>Total</td><td></td><td></td><td>258.0</td></tr><tr><td>Average</td><td>3.5833333333333335</td><td>6.7272727272727275</td><td>23.454545454545453</td></tr></tbody></table></div><p>这次的一些类复杂度高的原因其实和上次作业相同，因为担心改了出问题，所以并没有改动架构。</p><h3 id="bug-分析-2"><a href="#bug-分析-2" class="headerlink" title="bug 分析"></a>bug 分析</h3><p>本次作业遇到的bug是求导时，如果因子不含有求导变量，会返回null，然后出现了 $-dx(2) = 1$。在提交强测前已自检出。</p><h2 id="第一单元作业总结"><a href="#第一单元作业总结" class="headerlink" title="第一单元作业总结"></a>第一单元作业总结</h2><p>本单元作业结果上是ok的，但是架构上不太合适，比如可扩展性不太好，一些类复杂度比较高，一些可以复合的地方写的比较冗余。在以后的作业中，我觉得需要提前为下一次迭代预留空间，先思考好每个要求由哪些类实现，每个类实现哪些功能，减少类与类之间的耦合度。</p><p><em>如果发现写的有误或有更好的做法，欢迎到评论区指正或分享</em> (*^▽^*)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Object Oriented </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux虚拟机联不上网解决方法</title>
      <link href="/2023/02/28/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%81%94%E4%B8%8D%E4%B8%8A%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2023/02/28/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%81%94%E4%B8%8D%E4%B8%8A%E7%BD%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><em>在用docker下cellift的时候校园网时不时地会崩掉，后来把校园网连回去，虚拟机也没有网，搞了半天才连回去，故在此想记录一下过程。</em></p><h2 id="Centos命令行上下翻页"><a href="#Centos命令行上下翻页" class="headerlink" title="Centos命令行上下翻页"></a>Centos命令行上下翻页</h2><p><em>写博客的时候本来想翻一下刚刚的操作记录，结果发现不会翻页，进行了一番搜索和咨询大佬。</em></p><p>​        由于笔记本键盘中<code>PgUp</code> 和 <code>↑</code> 键合并在一起，所以不能直接用 <code>shift</code> + <code>PgUp</code>，而应该用 <code>shift</code> + <code>Fn</code> +  <code>PgUp</code> 。</p><h2 id="Linux虚拟机网络连接"><a href="#Linux虚拟机网络连接" class="headerlink" title="Linux虚拟机网络连接"></a>Linux虚拟机网络连接</h2><p><em>以下基于NAT网络连接模式（虚拟机 -&gt; 网络适配器 -&gt; 网络连接NAT模式）</em></p><h3 id="查看网络连接是否正常"><a href="#查看网络连接是否正常" class="headerlink" title="查看网络连接是否正常"></a>查看网络连接是否正常</h3><h4 id="查看本机与虚拟机是否连接正常"><a href="#查看本机与虚拟机是否连接正常" class="headerlink" title="查看本机与虚拟机是否连接正常"></a>查看本机与虚拟机是否连接正常</h4><h5 id="本机ping虚拟机"><a href="#本机ping虚拟机" class="headerlink" title="本机ping虚拟机"></a>本机ping虚拟机</h5><p><img src="https://s2.loli.net/2023/02/28/xXiBF67orkazPJT.png" alt=""></p><h5 id="虚拟机ping本机"><a href="#虚拟机ping本机" class="headerlink" title="虚拟机ping本机"></a>虚拟机ping本机</h5><p>​         在本机中打开 cmd ，输入 <code>ipconfig</code> 查看ip设置</p><p><img src="https://s2.loli.net/2023/02/28/NkWh3ay7gKEFXw1.png" alt="image-20230228132503621"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 10.193.4.233</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/28/2XWbu4znayOEQT6.png" alt="image-20230228132838410"></p><p>​        以上表示本机与虚拟机连接正常</p><pre><code>#### 2.2.2 虚拟机与远程网络连接</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/28/iRYOpFUJIzm7XAb.png" alt="image-20230228133154328"></p><h3 id="解决网络连接失败方法"><a href="#解决网络连接失败方法" class="headerlink" title="解决网络连接失败方法"></a>解决网络连接失败方法</h3><p>如果 <code>ping www.baidu.com: 未知的名称或服务</code>，说明网络连接有问题。</p><h4 id="检查网络配置文件"><a href="#检查网络配置文件" class="headerlink" title="检查网络配置文件"></a>检查网络配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/28/zpA3j96f5qxkmJc.png" alt="image-20230228134612519"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ONBOOT=&quot;yes&quot; #设置开机启动网络</span><br><span class="line">BOOTPROTO=&quot;static&quot; #设置静态IP，这样IP地址不会随着物理机IP地址的改变而改变</span><br><span class="line">IPADDR=192.168.33.123 #IP地址，前3位和GATEWAY一致</span><br><span class="line">NETMASK=255.255.255.0 #子网掩码</span><br><span class="line">GATEWAY=192.168.33.2 #设置网关，在虚拟网络编辑器中查看</span><br><span class="line">DNS=8.8.8.8</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/28/AUQHsRIvE2axXr4.png" alt="image-20230228134944158"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart #重启网卡</span><br></pre></td></tr></table></figure><p>此时可能出现以下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Job for network.service failed because the control process exited with error code. </span><br><span class="line">See &quot;systemctl status network.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure><p>该问题可以参考<a href="https://blog.csdn.net/u012904764/article/details/95883192">https://blog.csdn.net/u012904764/article/details/95883192</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解决方法</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止networkmanager服务</span></span><br><span class="line">systemctl stop NetworkManager</span><br><span class="line">systemctl disable NetworkManager</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启网卡</span></span><br><span class="line">systemctl restart network</span><br><span class="line">systemctl status network</span><br></pre></td></tr></table></figure><h4 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/resolv.conf</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/28/urGMtj9l67Hzwgn.png" alt="image-20230228141227466"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加DNS</span><br><span class="line">nameserver 8.8.8.8 #google的DNS</span><br></pre></td></tr></table></figure><p>最后再按照2.1步骤检查一遍，可以联网。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>我想把网络设置从NAT模式改为桥接模式，个人感觉是进行了一些正常操作，但是重启后右上角网络的角标失踪，网络无法连接，按上述操作完全行不通。于是，我参考了<a href="https://blog.csdn.net/m0_52709408/article/details/127527890?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-127527890-blog-125765055.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-127527890-blog-125765055.pc_relevant_default&amp;utm_relevant_index=1">这个方法 </a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nmcli networking off</span><br><span class="line">sudo nmcli networking on</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_44791658/article/details/119486115?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=ubuntu22.04%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119486115.142^v73^control,201^v4^add_ask,239^v2^insert_chatgpt&amp;spm=1018.2226.3001.4187">参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客使用操作记录</title>
      <link href="/2023/02/28/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/02/28/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><p>进入博客所在目录，右键点击 <code>Git Bash Here</code> ，创建博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;博客使用操作记录&quot;</span><br></pre></td></tr></table></figure><p>然后可以在source/_posts内查看新创建的 <code>.md</code>文件，在其中编写即可。</p><p>在 <code>front-matter</code> 内添加 <code>title</code>，<code>date</code>，<code>tags</code>，<code>description</code>，<code>cover</code>等描述文字。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编辑完成文章后，在git中输入</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>在博客所在仓库目录下新建 <code>CNAME</code> 文件，输入域名（如果自定义域名的话）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.cajzella.cn</span><br></pre></td></tr></table></figure><h2 id="ssh-连接-Github"><a href="#ssh-连接-Github" class="headerlink" title="ssh 连接 Github"></a>ssh 连接 Github</h2><p>当 Github中添加本地ssh公钥后，在 git 中输入 <code>ssh -T git@github.io</code> ，发现以下报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kex_exchange_identification: Connection closed by remote host</span><br><span class="line">ssh:connect to host github.com port 22: Connection timed out</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong></p><ul><li>修改 known_hosts，删除known_hosts.old。（原理参考<a href="https://cloud.tencent.com/developer/article/1946906）">https://cloud.tencent.com/developer/article/1946906）</a></li><li>删除博客目录下原有的 <code>.deploy_git</code> 和 <code>public</code> 文件。</li><li>后者报错<a href="https://blog.csdn.net/yjxkq99/article/details/128927038#:~:text=ssh%3Aconnect%20to%20host%20github.com%20port%2022%3A,Connection%20timed%20out%20%E9%80%9A%E8%BF%87%E6%9F%A5%E9%98%85%E5%90%84%E7%A7%8D%E8%B5%84%E6%96%99%EF%BC%8C%E5%BE%97%E7%9F%A5%E5%8E%9F%E5%9B%A0%E5%8F%AF%E8%83%BD%E6%98%AF%E7%94%B1%E4%BA%8E%E7%94%B5%E8%84%91%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4%20ssh%E8%BF%9E%E6%8E%A5%20%E6%96%B9%E5%BC%8F%20%E7%AB%AF%E5%8F%A322%E8%A2%AB%E5%B0%81%E9%94%81%E3%80%82">参考</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建回忆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CO实验总结</title>
      <link href="/2022/12/31/CO%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/31/CO%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><em>这是 CajZella 的学期末的 CO上机回忆录~</em></p><p>​        计算机组成原理课程分为理论课和实验课部分。理论课以<strong>MIPS系统</strong>为主要学习对象，讲述计算机硬件系统的组成、各部件的结构及其底层硬件的工作原理。实验课要求自主开发一台以MIPS处理器为核心的功能型计算机。</p><p>​        看到此，读者不必担忧。实验课是比较循序渐进的。在大二上学期开学前的两周左右，课程组会开放<a href="http://cscore.buaa.edu.cn/">实验教程</a>（<a href="https://vpn.buaa.edu.cn/portal/?redirect_uri=https%3A%2F%2Fcscore-buaa-edu-cn.vpn.buaa.edu.cn%3A8118%2F#!/login">VPN登录方式</a>）以供同学预习。在这期间，读者可以熟悉 <code>Logisim</code> ,  <code>Verilog</code>, <code>MIPS</code> 的环境及编写，完成实验教程对应的例题。当然如果暑假没有预习也不必担心，笔者同样在暑假没有学习相关内容，只是配置了<code>Logisim</code> , <code>ISE</code> , <code>Mars</code>等软件，在开学后会有四周预习时间（2021级），内容即为暑假开放的<code>Pre</code>。在第五周会迎来第一次上机 <code>Pre</code> , 时长为 $2.5h$ , <code>Logisim</code> ,  <code>Verilog</code>, <code>MIPS</code> 各一题，印象中对笔者来说比较难，当时未通过，不过本次上机不通过不会gap一周。接下来会是几乎每周各一次的上机：</p><ul><li><code>P0</code> , <code>P1</code> , <code>P2</code> 分别为  <code>Logisim</code> ,  <code>Verilog</code>, <code>MIPS</code> , 题型和 <code>Pre</code> 差不多；</li><li><code>P3</code> , <code>P4</code> 分别是 <code>Logisim</code> ，<code>Verilog</code> 开发MIPS单周期处理器（<code>P3</code> 开始进入正题）;</li><li><code>P5</code> 是 <code>Verilog</code> 开发单周期流水线CPU （<code>P5</code> 开始不会涉及 <code>Logisim</code>）;</li><li><code>P6</code> 在 <code>P5</code> 的基础上，扩展了乘除指令，需要<strong>模拟乘除模块的执行</strong>；</li><li><code>p7</code> 在 <code>P6</code> 的基础上，实现一个简单的计算机系统——MIPS微系统，需要处理<strong>内部溢出和外部中断</strong>，<strong>与外设交互</strong>；</li><li><code>P8</code> 要求在FPAG上实现系统验证，需要替换不可综合的部分，添加 <code>GPIO</code> , <code>DigitalTube</code> , <code>UART</code> 外设，编写软件实现一些功能。</li></ul><p>​        笔者认为CO实验是在涅槃中浴火重生的一场考验，作为进入计算机专业后的第一门专业课，注定是不平凡的。如果缺乏相应知识，仅仅阅读实验教程是难以顺利完成上机的，笔者认为还可借助以下资源：</p><ul><li>理论课的PPT和《数字设计和计算机体系结构》等教科书，对 <code>P3</code> 开始的CPU搭建会有一定帮助。</li><li>学长学姐们的博客和 github repo，会有历届学长学姐们的学习体会、测试数据、注意事项和课上回忆（注意每年题目可能会有变化）。</li><li>请教助教，助教们都非常亲切耐心，遇到问题百思不得其解的时候不要犹豫(＾Ｕ＾)ノ~ＹＯ </li><li>同学间的帮助，尤其是<code>P5</code>开始的流水线CPU，需要自己构造测试数据debug，可能遇到一些隐蔽性极好的bug，集思广益或许可以加快进度 O(∩_∩)O 。祝读者课上不会遇到课下的bug哇~</li></ul><p>​        “<strong>于高山之巅，方见大河奔涌；于群峰之上，更觉长风浩荡。</strong>” 这是一门由千千万万BUAA学子实践过的课程，其价值不断被凝练，祝你从中有所收获，更深入理解计算机组成原理。</p><p>​        21级老学姐就在此祝大家一路通关啦ヾ(✿ﾟ▽ﾟ)ノ </p>]]></content>
      
      
      
        <tags>
            
            <tag> CO实验 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
